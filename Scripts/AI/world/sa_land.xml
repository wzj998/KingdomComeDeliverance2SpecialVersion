<?xml version="1.0" encoding="us-ascii"?>
<BehaviorTrees>
	<BehaviorTree name="onUpdate" is_function="0">
		<Variables />
		<Root OneTimeOnly="false" FailState="Recoverable" saveVersion="2" />
		<ForestContainer />
		<EditorData EventSet="">
			<Variables />
			<ForwardDeclarations />
			<Root editorPosX="0" editorPosY="0" hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
				<OutputBreakpoints />
			</Root>
			<Forest />
			<Comments />
		</EditorData>
	</BehaviorTree>
	<BehaviorTree name="schedulerWait" is_function="0">
		<Variables />
		<Root OneTimeOnly="false" FailState="Recoverable" saveVersion="2">
			<Behavior canSkip="1">
				<Sequence>
					<WaitAction />
					<Wait duration="&apos;10s&apos;" timeType="GameTime" doFail="false" variation="" skipInLOD="false" />
				</Sequence>
			</Behavior>
		</Root>
		<ForestContainer />
		<EditorData EventSet="">
			<Variables />
			<ForwardDeclarations />
			<Root hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
				<OutputBreakpoints />
				<Behavior>
					<Sequence hasInputBreakpoint="0" comment="" breakpointFlags="0">
						<OutputBreakpoints />
						<WaitAction hasInputBreakpoint="0" comment="" breakpointFlags="0">
							<OutputBreakpoints />
						</WaitAction>
						<Wait hasInputBreakpoint="0" comment="" breakpointFlags="0">
							<OutputBreakpoints />
						</Wait>
					</Sequence>
				</Behavior>
			</Root>
			<Forest />
			<Comments />
		</EditorData>
	</BehaviorTree>
	<BehaviorTree name="leaveLevel" is_function="1">
		<Variables>
			<Variable name="chooseDetour" type="_bool" values="" isPersistent="0" form="single" />
			<Variable name="currentDetourTagpoint" type="_wuid" values="" isPersistent="0" form="single" />
			<Variable name="detourArea" type="_wuid" values="" isPersistent="0" form="single" />
			<Variable name="detourDirection" type="_string" values="" isPersistent="0" form="single" />
			<Variable name="detourTagpoints" type="_wuid" values="" isPersistent="0" form="array" />
			<Variable name="detouring" type="_bool" values="" isPersistent="0" form="single" />
			<Variable name="detouringFailedStraightUntilOutOfRepulsion" type="_bool" values="" isPersistent="0" form="single" />
			<Variable name="directions" type="_string" values="" isPersistent="0" form="array" />
			<Variable name="exitFound" type="_bool" values="" isPersistent="0" form="single" />
			<Variable name="exitLength" type="_int" values="" isPersistent="0" form="single" />
			<Variable name="groupCount" type="_int" values="" isPersistent="0" form="single" />
			<Variable name="horse" type="_wuid" values="" isPersistent="0" form="single" />
			<Variable name="horseBreak" type="_bool" values="" isPersistent="0" form="single" />
			<Variable name="horses" type="_wuid" values="" isPersistent="0" form="array" />
			<Variable name="i" type="_int" values="" isPersistent="0" form="single" />
			<Variable name="keepHorses" type="_bool" values="" isPersistent="0" form="single" />
			<Variable name="label" type="_string" values="" isPersistent="0" form="single" />
			<Variable name="levelExit" type="_wuid" values="" isPersistent="1" form="single" />
			<Variable name="levelExits" type="_wuid" values="" isPersistent="0" form="array" />
			<Variable name="notSeenByPlayer" type="_bool" values="" isPersistent="0" form="single" />
			<Variable name="playerHorse" type="_wuid" values="" isPersistent="0" form="single" />
			<Variable name="reloadBehavior" type="_bool" values="" isPersistent="0" form="single" />
			<Variable name="shortestDetourIndex" type="_int" values="" isPersistent="0" form="single" />
			<Variable name="shortestDirection" type="_string" values="" isPersistent="0" form="single" />
			<Variable name="shortestExitLength" type="_int" values="" isPersistent="0" form="single" />
			<Variable name="soul" type="_wuid" values="" isPersistent="0" form="single" />
			<Variable name="t_distanceMove_params" type="distanceMove_params:wuid" values="" isPersistent="0" form="single" />
			<Variable name="type" type="_string" values="" isPersistent="0" form="single" />
			<Variable name="usePath" type="_bool" values="" isPersistent="0" form="single" />
		</Variables>
		<Parameters>
			<Variable name="souls" type="_wuid" values="" isPersistent="0" form="array" requirementType="In" />
			<Variable name="speed" type="enum:movementSpeed" values="$enum:movementSpeed.walk" isPersistent="0" form="single" requirementType="In" />
		</Parameters>
		<Root OneTimeOnly="false" FailState="Recoverable" saveVersion="2">
			<Behavior canSkip="1">
				<Sequence>
					<IfCondition failOnCondition="false" condition="$levelExit == $__null">
						<Sequence>
							<GraphSearch Origin="$__land" Borders="" depth="1" selection="true" SearchPattern="Depth" EdgePruning="&apos;parent,inventory&apos;" AllowedEdges="" SubGraph="" AllowSubtraph="false" includeOrigin="false" excludeOrigin="false" failOnEmpty="true" SetOperationChoice="Intersection|And" errorOnEmpty="false" shortCircuit="false" skipTraversed="true">
								<CategoryFilter categories="&apos;levelExit&apos;" Source="Child" prune="true" negprune="unknown" Parent="" Child="" />
								<Nodalyzer Quantifiers="ForAll" Parent="" Child="$levelExits" saveVersion="2">
									<Child0 canSkip="1">
										<RangeSorter point="$this.id" SortOrder="Ascending" Source="Child" />
									</Child0>
								</Nodalyzer>
							</GraphSearch>
							<Expression expressions="$levelExit = $levelExits[0]" />
						</Sequence>
					</IfCondition>
					<Expression expressions="$groupCount = 0" />
					<ForEach startIndex="0" step="1" array="$souls" iterator="" value="$soul" break="">
						<Sequence>
							<GetType WUID="$soul" OutString="$type" ShowTrueIdentity="false" TreatPlayerAsNPC="true" />
							<IfElseCondition failOnCondition="false" condition="$type == &apos;NPC&apos;" saveVersion="2">
								<Then canSkip="1">
									<IsDeadCheck SoulWUID="$soul" FailSubtMissing="false" saveVersion="2">
										<Then canSkip="1">
											<Sequence>
												<Invertor>
													<GraphSearch Origin="$soul" Borders="" depth="1" selection="true" SearchPattern="Depth" EdgePruning="&apos;parent,inventory&apos;" AllowedEdges="" SubGraph="" AllowSubtraph="false" includeOrigin="true" excludeOrigin="false" failOnEmpty="true" SetOperationChoice="Intersection|And" errorOnEmpty="false" shortCircuit="false" skipTraversed="true">
														<IsHiddenFilter hideType="Any" Source="Child" prune="true" negprune="unknown" Parent="" Child="" />
														<WUIDFilter WUID="$soul" Source="Child" prune="true" negprune="unknown" Parent="" Child="" />
														<Nodalyzer Quantifiers="Exists" Parent="" Child="" saveVersion="2" />
													</GraphSearch>
												</Invertor>
												<Expression expressions="$groupCount+=1" />
											</Sequence>
										</Then>
										<Else canSkip="1">
											<Expression expressions="$groupCount+=1" />
										</Else>
									</IsDeadCheck>
								</Then>
								<Else canSkip="1">
									<PushToArray array="$horses" value="$soul" direction="Back" />
								</Else>
							</IfElseCondition>
						</Sequence>
					</ForEach>
					<Parallel successMode="Any" failureMode="Any">
						<ContinuousSwitch>
							<IfCondition failOnCondition="false" condition="$detouring">
								<Sequence>
									<Sequence>
										<Selector>
											<Sequence>
												<IsInsideAreaWithLabel Position="$this.id" Label="&apos;crime_publicEnemiesRepulsionZone&apos;" Area="$detourArea" FailSubtMissing="false" saveVersion="2">
													<Else canSkip="1">
														<Fail />
													</Else>
												</IsInsideAreaWithLabel>
												<Expression expressions="$label = &apos;crime_publicEnemiesRepulsionZone&apos;" />
											</Sequence>
											<Sequence>
												<IsInsideAreaWithLabel Position="$this.id" Label="&apos;crime_publicEnemiesRepulsionZone_minor&apos;" Area="$detourArea" FailSubtMissing="false" saveVersion="2">
													<Else canSkip="1">
														<Fail />
													</Else>
												</IsInsideAreaWithLabel>
												<Expression expressions="$label = &apos;crime_publicEnemiesRepulsionZone_minor&apos;" />
											</Sequence>
										</Selector>
										<Sequence>
											<Expression expressions="$shortestExitLength = 999 &#10;$directions[0] = &apos;clockwise&apos; &#10;$directions[1] = &apos;anticlockwise&apos;" />
											<ReinitVariable variable="$detourTagpoints" />
											<Selector>
												<GraphSearch Origin="$detourArea" Borders="" depth="1" selection="true" SearchPattern="Depth" EdgePruning="&apos;parent,inventory&apos;" AllowedEdges="" SubGraph="" AllowSubtraph="false" includeOrigin="false" excludeOrigin="false" failOnEmpty="true" SetOperationChoice="Intersection|And" errorOnEmpty="false" shortCircuit="false" skipTraversed="true">
													<LinkTagFilter tag="&apos;detour&apos;" prune="true" negprune="unknown" Parent="" Child="" Data="" />
													<Nodalyzer Quantifiers="ForAll" Parent="" Child="$detourTagpoints" saveVersion="2">
														<Child0 canSkip="1">
															<RangeSorter point="$this.id" SortOrder="Ascending" Source="Child" />
														</Child0>
													</Nodalyzer>
												</GraphSearch>
												<Sequence>
													<Expression expressions="$detouringFailedStraightUntilOutOfRepulsion = true" />
													<SuppressFailure>
														<ErrorNode Message="&apos;Area with repulsion label has no detour tagpoints linked for leave level behavior&apos;" />
													</SuppressFailure>
													<Function_leaveLevel_move destination="$levelExit" speed="$speed" usePaths="true" nodeLabel="25041711" />
												</Sequence>
											</Selector>
											<For startIndex="0" endIndex="2" step="1" array="$detourTagpoints" iterator="$i" value="" break="">
												<Sequence>
													<IfElseCondition failOnCondition="false" condition="$i == 0" saveVersion="2">
														<Then canSkip="1">
															<Expression expressions="$detourDirection = &apos;clockwise&apos;" />
														</Then>
														<Else canSkip="1">
															<Expression expressions="$detourDirection = &apos;anticlockwise&apos;" />
														</Else>
													</IfElseCondition>
													<ForEach startIndex="0" step="1" array="$directions" iterator="" value="$detourDirection" break="">
														<Sequence>
															<Expression expressions="$exitFound=false &#10;$exitLength = 0 &#10;$currentDetourTagpoint = $detourTagpoints[$i]" />
															<While doFail="false" propagateChildFail="false" condition="!$exitFound">
																<FuseBox StatusPropagation="Child" OneCleanup="false" saveVersion="2">
																	<Child canSkip="1">
																		<GraphSearch Origin="$currentDetourTagpoint" Borders="" depth="1" selection="true" SearchPattern="Depth" EdgePruning="&apos;parent,inventory&apos;" AllowedEdges="" SubGraph="" AllowSubtraph="false" includeOrigin="false" excludeOrigin="false" failOnEmpty="true" SetOperationChoice="Intersection|And" errorOnEmpty="false" shortCircuit="false" skipTraversed="true">
																			<LinkTagFilter tag="&apos;exit&apos;" prune="true" negprune="unknown" Parent="" Child="" Data="" />
																		</GraphSearch>
																	</Child>
																	<OnSuccess canSkip="1">
																		<Sequence>
																			<IfElseCondition failOnCondition="false" condition="$exitLength &lt; $shortestExitLength" saveVersion="2">
																				<Then canSkip="1">
																					<Expression expressions="$shortestExitLength = $exitLength &#10;$shortestDetourIndex = $i &#10;$shortestDirection = $detourDirection" />
																				</Then>
																			</IfElseCondition>
																			<Expression expressions="$exitFound = true" />
																		</Sequence>
																	</OnSuccess>
																	<OnFail canSkip="1">
																		<Sequence>
																			<GraphSearch Origin="$currentDetourTagpoint" Borders="" depth="1" selection="true" SearchPattern="Depth" EdgePruning="&apos;parent,inventory&apos;" AllowedEdges="" SubGraph="" AllowSubtraph="false" includeOrigin="false" excludeOrigin="false" failOnEmpty="true" SetOperationChoice="Intersection|And" errorOnEmpty="false" shortCircuit="false" skipTraversed="true">
																				<LinkTagFilter tag="$detourDirection" prune="true" negprune="unknown" Parent="" Child="$currentDetourTagpoint" Data="" />
																			</GraphSearch>
																			<Expression expressions="$exitLength += 1" />
																		</Sequence>
																	</OnFail>
																</FuseBox>
															</While>
														</Sequence>
													</ForEach>
												</Sequence>
											</For>
											<Expression expressions="$currentDetourTagpoint = $detourTagpoints[$shortestDetourIndex] &#10;$detouring = true" />
										</Sequence>
									</Sequence>
									<Expression expressions="$exitFound=false" />
									<While doFail="false" propagateChildFail="false" condition="!$exitFound">
										<Sequence>
											<Selector>
												<Sequence>
													<GraphSearch Origin="$currentDetourTagpoint" Borders="" depth="1" selection="true" SearchPattern="Depth" EdgePruning="&apos;parent,inventory&apos;" AllowedEdges="" SubGraph="" AllowSubtraph="false" includeOrigin="false" excludeOrigin="false" failOnEmpty="true" SetOperationChoice="Intersection|And" errorOnEmpty="false" shortCircuit="false" skipTraversed="true">
														<LinkTagFilter tag="&apos;usePath&apos;" prune="true" negprune="unknown" Parent="" Child="" Data="" />
													</GraphSearch>
													<Expression expressions="$usePath = true" />
												</Sequence>
												<Expression expressions="$usePath = false" />
											</Selector>
											<Function_leaveLevel_move destination="$currentDetourTagpoint" speed="$speed" usePaths="$usePath" nodeLabel="82926703" />
											<SuppressFailure>
												<Sequence>
													<GraphSearch Origin="$currentDetourTagpoint" Borders="" depth="1" selection="true" SearchPattern="Depth" EdgePruning="&apos;parent,inventory&apos;" AllowedEdges="" SubGraph="" AllowSubtraph="false" includeOrigin="false" excludeOrigin="false" failOnEmpty="true" SetOperationChoice="Intersection|And" errorOnEmpty="false" shortCircuit="false" skipTraversed="true">
														<LinkTagFilter tag="&apos;exit&apos;" prune="true" negprune="unknown" Parent="" Child="$levelExit" Data="" />
													</GraphSearch>
													<Expression expressions="$detouring = false" />
												</Sequence>
											</SuppressFailure>
											<GraphSearch Origin="$currentDetourTagpoint" Borders="" depth="1" selection="true" SearchPattern="Depth" EdgePruning="&apos;parent,inventory&apos;" AllowedEdges="" SubGraph="" AllowSubtraph="false" includeOrigin="false" excludeOrigin="false" failOnEmpty="true" SetOperationChoice="Intersection|And" errorOnEmpty="false" shortCircuit="false" skipTraversed="true">
												<LinkTagFilter tag="$shortestDirection" prune="true" negprune="unknown" Parent="" Child="$currentDetourTagpoint" Data="" />
											</GraphSearch>
										</Sequence>
									</While>
								</Sequence>
							</IfCondition>
							<IfCondition failOnCondition="false" condition="true">
								<Sequence>
									<Function_leaveLevel_move destination="$levelExit" speed="$speed" usePaths="true" nodeLabel="51809935" />
									<FuseBox StatusPropagation="Child" OneCleanup="false" saveVersion="2">
										<Child canSkip="1">
											<Synchronize SemaphoreCount="$groupCount" InsideTimerValue="&apos;10s&apos;" InvalidateOnExpire="false" atomic="false" OutsideQueuePosVariable="" InsidePosVariable="" TimerType="GameTime" OutsideTimerValue="&apos;-1&apos;" LockManagerType="Local" SemaphoreName="&apos;$souls[0]&apos;" RunLogic="KeepRunning">
												<Sequence>
													<ForEach startIndex="0" step="1" array="$horses" iterator="" value="$horse" break="$horseBreak">
														<DistanceCondition Origin="$__player" ReferencePt="$horse" Low="100.000000" High="100.000000" Negation="false" ValueOnMiddle="false" failOnCondition="false">
															<Expression expressions="$horseBreak=true" />
														</DistanceCondition>
													</ForEach>
													<IfElseCondition failOnCondition="false" condition="$horseBreak" saveVersion="2">
														<Then canSkip="1">
															<Success />
														</Then>
														<Else canSkip="1">
															<InstantCallback_empty EventName="&apos;UnstreamGroup&apos;" />
														</Else>
													</IfElseCondition>
												</Sequence>
											</Synchronize>
										</Child>
										<OnFail canSkip="1">
											<Expression expressions="$reloadBehavior = true" />
										</OnFail>
									</FuseBox>
								</Sequence>
							</IfCondition>
						</ContinuousSwitch>
						<Sequence>
							<Expression expressions="$chooseDetour = false" />
							<IsPublicEnemy Soul="$this.id" FailOnSubtreeMissing="false" saveVersion="2">
								<Then canSkip="1">
									<Expression expressions="$chooseDetour = true" />
								</Then>
							</IsPublicEnemy>
							<CheckRelationshipInterval_SoulToFaction TargetFaction="civilians" Soul="$this.id" Flag="enemy" saveVersion="2">
								<Then canSkip="1">
									<Expression expressions="$chooseDetour = true" />
								</Then>
							</CheckRelationshipInterval_SoulToFaction>
							<IfElseCondition failOnCondition="false" condition="$chooseDetour" saveVersion="2">
								<Then canSkip="1">
									<While doFail="false" propagateChildFail="false" condition="true">
										<Parallel successMode="Any" failureMode="Any">
											<IfGate atomic="false" condition="!$detouring | $detouringFailedStraightUntilOutOfRepulsion" RunLogic="Halt">
												<Parallel successMode="Any" failureMode="Any">
													<IsInsideAreaWithLabelBarrier Who="$this.id" Label="&apos;crime_publicEnemiesRepulsionZone&apos;" Negation="false" RunLogic="KeepRunning">
														<Expression expressions="$detouring = true" />
													</IsInsideAreaWithLabelBarrier>
													<IsInsideAreaWithLabelBarrier Who="$this.id" Label="&apos;crime_publicEnemiesRepulsionZone_minor&apos;" Negation="false" RunLogic="KeepRunning">
														<Expression expressions="$detouring = true" />
													</IsInsideAreaWithLabelBarrier>
												</Parallel>
											</IfGate>
											<IfGate atomic="false" condition="$detouringFailedStraightUntilOutOfRepulsion" RunLogic="Halt">
												<Parallel successMode="Any" failureMode="Any">
													<IsInsideAreaWithLabelBarrier Who="$this.id" Label="$label" Negation="true" RunLogic="KeepRunning">
														<Expression expressions="$detouring = false &#10;$detouringFailedStraightUntilOutOfRepulsion = false" />
													</IsInsideAreaWithLabelBarrier>
												</Parallel>
											</IfGate>
										</Parallel>
									</While>
								</Then>
								<Else canSkip="1">
									<Wait duration="&apos;-1&apos;" timeType="GameTime" doFail="false" variation="" />
								</Else>
							</IfElseCondition>
						</Sequence>
						<IfGate atomic="false" condition="$reloadBehavior == true" RunLogic="KeepRunning">
							<Success />
						</IfGate>
					</Parallel>
				</Sequence>
			</Behavior>
		</Root>
		<ForestContainer>
			<While doFail="false" propagateChildFail="false" condition="true">
				<Sequence>
					<NotSeenByPlayer target="$this.id" timespan="&apos;2m&apos;" result="$notSeenByPlayer" />
					<IfElseCondition failOnCondition="false" condition="$notSeenByPlayer" saveVersion="2">
						<Then canSkip="1">
							<DistanceCondition Origin="$this.id" ReferencePt="$__player" Low="0.000000" High="40.000000" Negation="true" ValueOnMiddle="false" failOnCondition="false">
								<SuppressFailure />
							</DistanceCondition>
						</Then>
						<Else canSkip="1">
							<Wait duration="&apos;2500ms&apos;" timeType="GameTime" doFail="false" variation="" />
						</Else>
					</IfElseCondition>
				</Sequence>
			</While>
			<Sequence>
				<Invertor>
					<GraphSearch Origin="$this.id" Borders="" depth="1" selection="true" SearchPattern="Depth" EdgePruning="&apos;parent,inventory&apos;" AllowedEdges="" SubGraph="" AllowSubtraph="false" includeOrigin="true" excludeOrigin="false" failOnEmpty="true" SetOperationChoice="Intersection|And" errorOnEmpty="false" shortCircuit="false" skipTraversed="true">
						<IsHiddenFilter hideType="NPCVisibility" Source="Child" prune="true" negprune="unknown" Parent="" Child="" />
						<WUIDFilter WUID="$this.id" Source="Child" prune="true" negprune="unknown" Parent="" Child="" />
						<Nodalyzer Quantifiers="Exists" Parent="" Child="" saveVersion="2" />
					</GraphSearch>
				</Invertor>
				<Expression expressions="$groupCount+=1" />
			</Sequence>
			<IsDeadCheck SoulWUID="$horse" FailSubtMissing="false" saveVersion="2">
				<Then canSkip="1">
					<Sequence>
						<Invertor>
							<GraphSearch Origin="$horse" Borders="" depth="1" selection="true" SearchPattern="Depth" EdgePruning="&apos;parent,inventory&apos;" AllowedEdges="" SubGraph="" AllowSubtraph="false" includeOrigin="true" excludeOrigin="false" failOnEmpty="true" SetOperationChoice="Intersection|And" errorOnEmpty="false" shortCircuit="false" skipTraversed="true">
								<IsHiddenFilter hideType="NPCVisibility" Source="Child" prune="true" negprune="unknown" Parent="" Child="" />
								<WUIDFilter WUID="$this.id" Source="Child" prune="true" negprune="unknown" Parent="" Child="" />
								<Nodalyzer Quantifiers="Exists" Parent="" Child="" saveVersion="2" />
							</GraphSearch>
						</Invertor>
						<Expression expressions="$horseBreak=true" />
					</Sequence>
				</Then>
			</IsDeadCheck>
			<For startIndex="0" endIndex="-1" step="1" array="$detourTagpoints" iterator="$detourIterator" value="" break="$exitFound" />
		</ForestContainer>
		<EditorData Signature="leaveLevel" EventSet="leaveLevel">
			<Variables>
				<Variable name="chooseDetour" comment="" />
				<Variable name="currentDetourTagpoint" comment="" />
				<Variable name="detourArea" comment="" />
				<Variable name="detourDirection" comment="" />
				<Variable name="detourTagpoints" comment="" />
				<Variable name="detouring" comment="" />
				<Variable name="detouringFailedStraightUntilOutOfRepulsion" comment="" />
				<Variable name="directions" comment="" />
				<Variable name="exitFound" comment="" />
				<Variable name="exitLength" comment="" />
				<Variable name="groupCount" comment="" />
				<Variable name="horse" comment="" />
				<Variable name="horseBreak" comment="" />
				<Variable name="horses" comment="" />
				<Variable name="i" comment="" />
				<Variable name="keepHorses" comment="" />
				<Variable name="label" comment="" />
				<Variable name="levelExit" comment="" />
				<Variable name="levelExits" comment="" />
				<Variable name="notSeenByPlayer" comment="" />
				<Variable name="playerHorse" comment="" />
				<Variable name="reloadBehavior" comment="" />
				<Variable name="shortestDetourIndex" comment="" />
				<Variable name="shortestDirection" comment="" />
				<Variable name="shortestExitLength" comment="" />
				<Variable name="soul" comment="" />
				<Variable name="t_distanceMove_params" comment="" />
				<Variable name="type" comment="" />
				<Variable name="usePath" comment="" />
				<Variable name="souls" comment="" />
				<Variable name="speed" comment="" />
			</Variables>
			<ForwardDeclarations />
			<Root editorPosX="-40" editorPosY="-260" hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
				<OutputBreakpoints />
				<Behavior>
					<Sequence hasInputBreakpoint="0" comment="" breakpointFlags="0">
						<OutputBreakpoints />
						<IfCondition hasInputBreakpoint="0" comment="" breakpointFlags="0">
							<OutputBreakpoints />
							<Sequence hasInputBreakpoint="0" comment="" breakpointFlags="0">
								<OutputBreakpoints />
								<GraphSearch hasInputBreakpoint="0" comment="" breakpointFlags="0">
									<OutputBreakpoints />
									<CategoryFilter hasInputBreakpoint="0" comment="" breakpointFlags="0">
										<OutputBreakpoints />
									</CategoryFilter>
									<Nodalyzer hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
										<OutputBreakpoints />
										<Child0>
											<RangeSorter hasInputBreakpoint="0" comment="" breakpointFlags="0">
												<OutputBreakpoints />
											</RangeSorter>
										</Child0>
									</Nodalyzer>
								</GraphSearch>
								<Expression hasInputBreakpoint="0" comment="" breakpointFlags="0">
									<OutputBreakpoints />
								</Expression>
							</Sequence>
						</IfCondition>
						<Expression hasInputBreakpoint="0" comment="" breakpointFlags="0">
							<OutputBreakpoints />
						</Expression>
						<ForEach hasInputBreakpoint="0" comment="" breakpointFlags="0">
							<OutputBreakpoints />
							<Sequence hasInputBreakpoint="0" comment="" breakpointFlags="0">
								<OutputBreakpoints />
								<GetType hasInputBreakpoint="0" comment="" breakpointFlags="0">
									<OutputBreakpoints />
								</GetType>
								<IfElseCondition hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
									<OutputBreakpoints />
									<Then>
										<IsDeadCheck hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
											<OutputBreakpoints />
											<Then>
												<Sequence hasInputBreakpoint="0" comment="" breakpointFlags="0">
													<OutputBreakpoints />
													<Invertor hasInputBreakpoint="0" comment="" breakpointFlags="0">
														<OutputBreakpoints />
														<GraphSearch hasInputBreakpoint="0" comment="" breakpointFlags="0">
															<OutputBreakpoints />
															<IsHiddenFilter hasInputBreakpoint="0" comment="" breakpointFlags="0">
																<OutputBreakpoints />
															</IsHiddenFilter>
															<WUIDFilter hasInputBreakpoint="0" comment="" breakpointFlags="0">
																<OutputBreakpoints />
															</WUIDFilter>
															<Nodalyzer hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
																<OutputBreakpoints />
															</Nodalyzer>
														</GraphSearch>
													</Invertor>
													<Expression hasInputBreakpoint="0" comment="" breakpointFlags="0">
														<OutputBreakpoints />
													</Expression>
												</Sequence>
											</Then>
											<Else>
												<Expression hasInputBreakpoint="0" comment="" breakpointFlags="0">
													<OutputBreakpoints />
												</Expression>
											</Else>
										</IsDeadCheck>
									</Then>
									<Else>
										<PushToArray hasInputBreakpoint="0" comment="" breakpointFlags="0">
											<OutputBreakpoints />
										</PushToArray>
									</Else>
								</IfElseCondition>
							</Sequence>
						</ForEach>
						<Parallel hasInputBreakpoint="0" comment="" breakpointFlags="0">
							<OutputBreakpoints />
							<ContinuousSwitch hasInputBreakpoint="0" comment="" breakpointFlags="0">
								<OutputBreakpoints />
								<IfCondition hasInputBreakpoint="0" comment="" breakpointFlags="0">
									<OutputBreakpoints />
									<Sequence hasInputBreakpoint="0" comment="" breakpointFlags="0">
										<OutputBreakpoints />
										<Sequence hasInputBreakpoint="0" comment="" breakpointFlags="0">
											<OutputBreakpoints />
											<Selector hasInputBreakpoint="0" comment="" breakpointFlags="0">
												<OutputBreakpoints />
												<Sequence hasInputBreakpoint="0" comment="" breakpointFlags="0">
													<OutputBreakpoints />
													<IsInsideAreaWithLabel hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
														<OutputBreakpoints />
														<Else>
															<Fail hasInputBreakpoint="0" comment="" breakpointFlags="0">
																<OutputBreakpoints />
															</Fail>
														</Else>
													</IsInsideAreaWithLabel>
													<Expression hasInputBreakpoint="0" comment="" breakpointFlags="0">
														<OutputBreakpoints />
													</Expression>
												</Sequence>
												<Sequence hasInputBreakpoint="0" comment="" breakpointFlags="0">
													<OutputBreakpoints />
													<IsInsideAreaWithLabel hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
														<OutputBreakpoints />
														<Else>
															<Fail hasInputBreakpoint="0" comment="" breakpointFlags="0">
																<OutputBreakpoints />
															</Fail>
														</Else>
													</IsInsideAreaWithLabel>
													<Expression hasInputBreakpoint="0" comment="" breakpointFlags="0">
														<OutputBreakpoints />
													</Expression>
												</Sequence>
											</Selector>
											<Sequence hasInputBreakpoint="0" comment="" breakpointFlags="0">
												<OutputBreakpoints />
												<Expression hasInputBreakpoint="0" comment="" breakpointFlags="0">
													<OutputBreakpoints />
												</Expression>
												<ReinitVariable hasInputBreakpoint="0" comment="" breakpointFlags="0">
													<OutputBreakpoints />
												</ReinitVariable>
												<Selector hasInputBreakpoint="0" comment="" breakpointFlags="0">
													<OutputBreakpoints />
													<GraphSearch hasInputBreakpoint="0" comment="" breakpointFlags="0">
														<OutputBreakpoints />
														<LinkTagFilter hasInputBreakpoint="0" comment="" breakpointFlags="0">
															<OutputBreakpoints />
														</LinkTagFilter>
														<Nodalyzer hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
															<OutputBreakpoints />
															<Child0>
																<RangeSorter hasInputBreakpoint="0" comment="" breakpointFlags="0">
																	<OutputBreakpoints />
																</RangeSorter>
															</Child0>
														</Nodalyzer>
													</GraphSearch>
													<Sequence hasInputBreakpoint="0" comment="" breakpointFlags="0">
														<OutputBreakpoints />
														<Expression hasInputBreakpoint="0" comment="" breakpointFlags="0">
															<OutputBreakpoints />
														</Expression>
														<SuppressFailure hasInputBreakpoint="0" comment="" breakpointFlags="0">
															<OutputBreakpoints />
															<ErrorNode hasInputBreakpoint="0" comment="" breakpointFlags="0">
																<OutputBreakpoints />
															</ErrorNode>
														</SuppressFailure>
														<Function_leaveLevel_move hasInputBreakpoint="0" comment="" breakpointFlags="0">
															<OutputBreakpoints />
														</Function_leaveLevel_move>
													</Sequence>
												</Selector>
												<For hasInputBreakpoint="0" comment="" breakpointFlags="0">
													<OutputBreakpoints />
													<Sequence hasInputBreakpoint="0" comment="" breakpointFlags="0">
														<OutputBreakpoints />
														<IfElseCondition hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
															<OutputBreakpoints />
															<Then>
																<Expression hasInputBreakpoint="0" comment="" breakpointFlags="0">
																	<OutputBreakpoints />
																</Expression>
															</Then>
															<Else>
																<Expression hasInputBreakpoint="0" comment="" breakpointFlags="0">
																	<OutputBreakpoints />
																</Expression>
															</Else>
														</IfElseCondition>
														<ForEach hasInputBreakpoint="0" comment="" breakpointFlags="0">
															<OutputBreakpoints />
															<Sequence hasInputBreakpoint="0" comment="" breakpointFlags="0">
																<OutputBreakpoints />
																<Expression hasInputBreakpoint="0" comment="" breakpointFlags="0">
																	<OutputBreakpoints />
																</Expression>
																<While hasInputBreakpoint="0" comment="" breakpointFlags="0">
																	<OutputBreakpoints />
																	<FuseBox hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
																		<OutputBreakpoints />
																		<Child>
																			<GraphSearch hasInputBreakpoint="0" comment="" breakpointFlags="0">
																				<OutputBreakpoints />
																				<LinkTagFilter hasInputBreakpoint="0" comment="" breakpointFlags="0">
																					<OutputBreakpoints />
																				</LinkTagFilter>
																			</GraphSearch>
																		</Child>
																		<OnSuccess>
																			<Sequence hasInputBreakpoint="0" comment="" breakpointFlags="0">
																				<OutputBreakpoints />
																				<IfElseCondition hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
																					<OutputBreakpoints />
																					<Then>
																						<Expression hasInputBreakpoint="0" comment="" breakpointFlags="0">
																							<OutputBreakpoints />
																						</Expression>
																					</Then>
																				</IfElseCondition>
																				<Expression hasInputBreakpoint="0" comment="" breakpointFlags="0">
																					<OutputBreakpoints />
																				</Expression>
																			</Sequence>
																		</OnSuccess>
																		<OnFail>
																			<Sequence hasInputBreakpoint="0" comment="" breakpointFlags="0">
																				<OutputBreakpoints />
																				<GraphSearch hasInputBreakpoint="0" comment="" breakpointFlags="0">
																					<OutputBreakpoints />
																					<LinkTagFilter hasInputBreakpoint="0" comment="" breakpointFlags="0">
																						<OutputBreakpoints />
																					</LinkTagFilter>
																				</GraphSearch>
																				<Expression hasInputBreakpoint="0" comment="" breakpointFlags="0">
																					<OutputBreakpoints />
																				</Expression>
																			</Sequence>
																		</OnFail>
																	</FuseBox>
																</While>
															</Sequence>
														</ForEach>
													</Sequence>
												</For>
												<Expression hasInputBreakpoint="0" comment="" breakpointFlags="0">
													<OutputBreakpoints />
												</Expression>
											</Sequence>
										</Sequence>
										<Expression hasInputBreakpoint="0" comment="" breakpointFlags="0">
											<OutputBreakpoints />
										</Expression>
										<While hasInputBreakpoint="0" comment="" breakpointFlags="0">
											<OutputBreakpoints />
											<Sequence hasInputBreakpoint="0" comment="" breakpointFlags="0">
												<OutputBreakpoints />
												<Selector hasInputBreakpoint="0" comment="" breakpointFlags="0">
													<OutputBreakpoints />
													<Sequence hasInputBreakpoint="0" comment="" breakpointFlags="0">
														<OutputBreakpoints />
														<GraphSearch hasInputBreakpoint="0" comment="" breakpointFlags="0">
															<OutputBreakpoints />
															<LinkTagFilter hasInputBreakpoint="0" comment="" breakpointFlags="0">
																<OutputBreakpoints />
															</LinkTagFilter>
														</GraphSearch>
														<Expression hasInputBreakpoint="0" comment="" breakpointFlags="0">
															<OutputBreakpoints />
														</Expression>
													</Sequence>
													<Expression hasInputBreakpoint="0" comment="" breakpointFlags="0">
														<OutputBreakpoints />
													</Expression>
												</Selector>
												<Function_leaveLevel_move hasInputBreakpoint="0" comment="" breakpointFlags="0">
													<OutputBreakpoints />
												</Function_leaveLevel_move>
												<SuppressFailure hasInputBreakpoint="0" comment="" breakpointFlags="0">
													<OutputBreakpoints />
													<Sequence hasInputBreakpoint="0" comment="" breakpointFlags="0">
														<OutputBreakpoints />
														<GraphSearch hasInputBreakpoint="0" comment="" breakpointFlags="0">
															<OutputBreakpoints />
															<LinkTagFilter hasInputBreakpoint="0" comment="" breakpointFlags="0">
																<OutputBreakpoints />
															</LinkTagFilter>
														</GraphSearch>
														<Expression hasInputBreakpoint="0" comment="" breakpointFlags="0">
															<OutputBreakpoints />
														</Expression>
													</Sequence>
												</SuppressFailure>
												<GraphSearch hasInputBreakpoint="0" comment="" breakpointFlags="0">
													<OutputBreakpoints />
													<LinkTagFilter hasInputBreakpoint="0" comment="" breakpointFlags="0">
														<OutputBreakpoints />
													</LinkTagFilter>
												</GraphSearch>
											</Sequence>
										</While>
									</Sequence>
								</IfCondition>
								<IfCondition hasInputBreakpoint="0" comment="" breakpointFlags="0">
									<OutputBreakpoints />
									<Sequence hasInputBreakpoint="0" comment="" breakpointFlags="0">
										<OutputBreakpoints />
										<Function_leaveLevel_move hasInputBreakpoint="0" comment="" breakpointFlags="0">
											<OutputBreakpoints />
										</Function_leaveLevel_move>
										<FuseBox hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
											<OutputBreakpoints />
											<Child>
												<Synchronize hasInputBreakpoint="0" comment="" breakpointFlags="0">
													<OutputBreakpoints />
													<Sequence hasInputBreakpoint="0" comment="" breakpointFlags="0">
														<OutputBreakpoints />
														<ForEach hasInputBreakpoint="0" comment="" breakpointFlags="0">
															<OutputBreakpoints />
															<DistanceCondition hasInputBreakpoint="0" comment="" breakpointFlags="0">
																<OutputBreakpoints />
																<Expression hasInputBreakpoint="0" comment="" breakpointFlags="0">
																	<OutputBreakpoints />
																</Expression>
															</DistanceCondition>
														</ForEach>
														<IfElseCondition hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
															<OutputBreakpoints />
															<Then>
																<Success hasInputBreakpoint="0" comment="" breakpointFlags="0">
																	<OutputBreakpoints />
																</Success>
															</Then>
															<Else>
																<InstantCallback_empty hasInputBreakpoint="0" comment="" breakpointFlags="0">
																	<OutputBreakpoints />
																</InstantCallback_empty>
															</Else>
														</IfElseCondition>
													</Sequence>
												</Synchronize>
											</Child>
											<OnFail>
												<Expression hasInputBreakpoint="0" comment="" breakpointFlags="0">
													<OutputBreakpoints />
												</Expression>
											</OnFail>
										</FuseBox>
									</Sequence>
								</IfCondition>
							</ContinuousSwitch>
							<Sequence hasInputBreakpoint="0" comment="" breakpointFlags="0">
								<OutputBreakpoints />
								<Expression hasInputBreakpoint="0" comment="" breakpointFlags="0">
									<OutputBreakpoints />
								</Expression>
								<IsPublicEnemy hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
									<OutputBreakpoints />
									<Then>
										<Expression hasInputBreakpoint="0" comment="" breakpointFlags="0">
											<OutputBreakpoints />
										</Expression>
									</Then>
								</IsPublicEnemy>
								<CheckRelationshipInterval_SoulToFaction hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
									<OutputBreakpoints />
									<Then>
										<Expression hasInputBreakpoint="0" comment="" breakpointFlags="0">
											<OutputBreakpoints />
										</Expression>
									</Then>
								</CheckRelationshipInterval_SoulToFaction>
								<IfElseCondition hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
									<OutputBreakpoints />
									<Then>
										<While hasInputBreakpoint="0" comment="" breakpointFlags="0">
											<OutputBreakpoints />
											<Parallel hasInputBreakpoint="0" comment="" breakpointFlags="0">
												<OutputBreakpoints />
												<IfGate hasInputBreakpoint="0" comment="" breakpointFlags="0">
													<OutputBreakpoints />
													<Parallel hasInputBreakpoint="0" comment="" breakpointFlags="0">
														<OutputBreakpoints />
														<IsInsideAreaWithLabelBarrier hasInputBreakpoint="0" comment="" breakpointFlags="0">
															<OutputBreakpoints />
															<Expression hasInputBreakpoint="0" comment="" breakpointFlags="0">
																<OutputBreakpoints />
															</Expression>
														</IsInsideAreaWithLabelBarrier>
														<IsInsideAreaWithLabelBarrier hasInputBreakpoint="0" comment="" breakpointFlags="0">
															<OutputBreakpoints />
															<Expression hasInputBreakpoint="0" comment="" breakpointFlags="0">
																<OutputBreakpoints />
															</Expression>
														</IsInsideAreaWithLabelBarrier>
													</Parallel>
												</IfGate>
												<IfGate hasInputBreakpoint="0" comment="" breakpointFlags="0">
													<OutputBreakpoints />
													<Parallel hasInputBreakpoint="0" comment="" breakpointFlags="0">
														<OutputBreakpoints />
														<IsInsideAreaWithLabelBarrier hasInputBreakpoint="0" comment="" breakpointFlags="0">
															<OutputBreakpoints />
															<Expression hasInputBreakpoint="0" comment="" breakpointFlags="0">
																<OutputBreakpoints />
															</Expression>
														</IsInsideAreaWithLabelBarrier>
													</Parallel>
												</IfGate>
											</Parallel>
										</While>
									</Then>
									<Else>
										<Wait hasInputBreakpoint="0" comment="" breakpointFlags="0">
											<OutputBreakpoints />
										</Wait>
									</Else>
								</IfElseCondition>
							</Sequence>
							<IfGate hasInputBreakpoint="0" comment="" breakpointFlags="0">
								<OutputBreakpoints />
								<Success hasInputBreakpoint="0" comment="" breakpointFlags="0">
									<OutputBreakpoints />
								</Success>
							</IfGate>
						</Parallel>
					</Sequence>
				</Behavior>
			</Root>
			<Forest>
				<While editorPosX="1730" editorPosY="1810" hasInputBreakpoint="0" comment="" breakpointFlags="0">
					<OutputBreakpoints />
					<Sequence hasInputBreakpoint="0" comment="" breakpointFlags="0">
						<OutputBreakpoints />
						<NotSeenByPlayer hasInputBreakpoint="0" comment="" breakpointFlags="0">
							<OutputBreakpoints />
						</NotSeenByPlayer>
						<IfElseCondition hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
							<OutputBreakpoints />
							<Then>
								<DistanceCondition hasInputBreakpoint="0" comment="" breakpointFlags="0">
									<OutputBreakpoints />
									<SuppressFailure hasInputBreakpoint="0" comment="" breakpointFlags="0">
										<OutputBreakpoints />
									</SuppressFailure>
								</DistanceCondition>
							</Then>
							<Else>
								<Wait hasInputBreakpoint="0" comment="" breakpointFlags="0">
									<OutputBreakpoints />
								</Wait>
							</Else>
						</IfElseCondition>
					</Sequence>
				</While>
				<Sequence editorPosX="2650" editorPosY="-980" hasInputBreakpoint="1" comment="" comment_box="After_Hiding_dead_bodies_technology_is_back" comment_box_color="222,222,222,222" breakpointFlags="1">
					<OutputBreakpoints />
					<Invertor hasInputBreakpoint="1" comment="" breakpointFlags="1">
						<OutputBreakpoints />
						<GraphSearch hasInputBreakpoint="1" comment="" breakpointFlags="1">
							<OutputBreakpoints />
							<IsHiddenFilter hasInputBreakpoint="1" comment="" breakpointFlags="1">
								<OutputBreakpoints />
							</IsHiddenFilter>
							<WUIDFilter hasInputBreakpoint="1" comment="" breakpointFlags="1">
								<OutputBreakpoints />
							</WUIDFilter>
							<Nodalyzer hasInputBreakpoint="1" comment="" breakpointFlags="1" saveVersion="2">
								<OutputBreakpoints />
							</Nodalyzer>
						</GraphSearch>
					</Invertor>
					<Expression hasInputBreakpoint="1" comment="" breakpointFlags="1">
						<OutputBreakpoints />
					</Expression>
				</Sequence>
				<IsDeadCheck editorPosX="3930" editorPosY="370" hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
					<OutputBreakpoints />
					<Then>
						<Sequence hasInputBreakpoint="0" comment="" breakpointFlags="0">
							<OutputBreakpoints />
							<Invertor hasInputBreakpoint="0" comment="" comment_box="After_Hiding_dead_bodies_technology_is_back" comment_box_color="222,222,222,222" breakpointFlags="0">
								<OutputBreakpoints />
								<GraphSearch hasInputBreakpoint="0" comment="" breakpointFlags="0">
									<OutputBreakpoints />
									<IsHiddenFilter hasInputBreakpoint="0" comment="" breakpointFlags="0">
										<OutputBreakpoints />
									</IsHiddenFilter>
									<WUIDFilter hasInputBreakpoint="0" comment="" breakpointFlags="0">
										<OutputBreakpoints />
									</WUIDFilter>
									<Nodalyzer hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
										<OutputBreakpoints />
									</Nodalyzer>
								</GraphSearch>
							</Invertor>
							<Expression hasInputBreakpoint="0" comment="" breakpointFlags="0">
								<OutputBreakpoints />
							</Expression>
						</Sequence>
					</Then>
				</IsDeadCheck>
				<For editorPosX="1700" editorPosY="1790" hasInputBreakpoint="0" comment="" breakpointFlags="0">
					<OutputBreakpoints />
				</For>
			</Forest>
			<Comments />
		</EditorData>
	</BehaviorTree>
	<BehaviorTree name="leaveLevel_despawn" is_function="1">
		<Variables />
		<Root OneTimeOnly="false" FailState="Recoverable" saveVersion="2">
			<Behavior canSkip="1">
				<Despawn DeSpawnedEntity="$this.id" />
			</Behavior>
		</Root>
		<ForestContainer />
		<EditorData EventSet="">
			<Variables />
			<ForwardDeclarations />
			<Root editorPosX="-140" hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
				<OutputBreakpoints />
				<Behavior>
					<Despawn hasInputBreakpoint="0" comment="" breakpointFlags="0">
						<OutputBreakpoints />
					</Despawn>
				</Behavior>
			</Root>
			<Forest />
			<Comments />
		</EditorData>
	</BehaviorTree>
	<BehaviorTree name="teleport" is_function="0">
		<Variables />
		<Parameters>
			<Variable name="destination" type="_wuid" values="" isPersistent="0" form="single" requirementType="In" />
		</Parameters>
		<Root OneTimeOnly="false" FailState="Error" saveVersion="2">
			<Behavior canSkip="1">
				<Switch>
					<IsDeadCheck SoulWUID="$this.id" FailSubtMissing="false" saveVersion="2">
						<Then canSkip="1">
							<EntityContext context="ForceForbidAutoTorch" target="">
								<Sequence>
									<TeleportAction Position="$destination" EndInterruptOnActionStart="false" />
									<SuppressFailure>
										<UrgencyDecorator Urgency="Instant">
											<EntityContext context="deadBody_allowActorAnimsForDeadNPC" target="">
												<AnimationAction fragment="&apos;RagdollAction&apos;" tags="" eventReferenceObject="" alignObject="" slaveObject="" resourceOverride="" allowTorchForPlayer="false" />
											</EntityContext>
										</UrgencyDecorator>
									</SuppressFailure>
								</Sequence>
							</EntityContext>
						</Then>
					</IsDeadCheck>
					<EntityContextCheck context="teleport_crime_keepItems" target="" saveVersion="2">
						<Then canSkip="1">
							<AnyDecorator preset="crime_keepItems" enabled="true">
								<TeleportAction Position="$destination" EndInterruptOnActionStart="true" />
							</AnyDecorator>
						</Then>
					</EntityContextCheck>
					<EntityContextCheck context="teleport_keepClothes" target="" saveVersion="2">
						<Then canSkip="1">
							<AnyDecorator preset="teleport_keepClothes" enabled="true">
								<TeleportAction Position="$destination" EndInterruptOnActionStart="true" />
							</AnyDecorator>
						</Then>
					</EntityContextCheck>
					<DefaultBranch>
						<TeleportAction Position="$destination" EndInterruptOnActionStart="true" />
					</DefaultBranch>
				</Switch>
			</Behavior>
		</Root>
		<ForestContainer />
		<EditorData Signature="teleport" EventSet="">
			<Variables>
				<Variable name="destination" comment="" />
			</Variables>
			<ForwardDeclarations />
			<Root hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
				<OutputBreakpoints />
				<Behavior>
					<Switch hasInputBreakpoint="0" comment="" breakpointFlags="0">
						<OutputBreakpoints />
						<IsDeadCheck hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
							<OutputBreakpoints />
							<Then>
								<EntityContext hasInputBreakpoint="0" comment="" breakpointFlags="0">
									<OutputBreakpoints />
									<Sequence hasInputBreakpoint="0" comment="" breakpointFlags="0">
										<OutputBreakpoints />
										<TeleportAction hasInputBreakpoint="0" comment="" breakpointFlags="0">
											<OutputBreakpoints />
										</TeleportAction>
										<SuppressFailure hasInputBreakpoint="0" comment="" breakpointFlags="0">
											<OutputBreakpoints />
											<UrgencyDecorator hasInputBreakpoint="0" comment="" breakpointFlags="0">
												<OutputBreakpoints />
												<EntityContext hasInputBreakpoint="0" comment="" breakpointFlags="0">
													<OutputBreakpoints />
													<AnimationAction hasInputBreakpoint="0" comment="" breakpointFlags="0">
														<OutputBreakpoints />
													</AnimationAction>
												</EntityContext>
											</UrgencyDecorator>
										</SuppressFailure>
									</Sequence>
								</EntityContext>
							</Then>
						</IsDeadCheck>
						<EntityContextCheck hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
							<OutputBreakpoints />
							<Then>
								<AnyDecorator hasInputBreakpoint="0" comment="" breakpointFlags="0">
									<OutputBreakpoints />
									<TeleportAction hasInputBreakpoint="0" comment="" breakpointFlags="0">
										<OutputBreakpoints />
									</TeleportAction>
								</AnyDecorator>
							</Then>
						</EntityContextCheck>
						<EntityContextCheck hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
							<OutputBreakpoints />
							<Then>
								<AnyDecorator hasInputBreakpoint="0" comment="" breakpointFlags="0">
									<OutputBreakpoints />
									<TeleportAction hasInputBreakpoint="0" comment="" breakpointFlags="0">
										<OutputBreakpoints />
									</TeleportAction>
								</AnyDecorator>
							</Then>
						</EntityContextCheck>
						<DefaultBranch>
							<TeleportAction hasInputBreakpoint="0" comment="" breakpointFlags="0">
								<OutputBreakpoints />
							</TeleportAction>
						</DefaultBranch>
					</Switch>
				</Behavior>
			</Root>
			<Forest />
			<Comments />
		</EditorData>
	</BehaviorTree>
	<BehaviorTree name="combat_fightRepeated_template" is_function="1">
		<Variables>
			<Variable name="priority" type="_int" values="" isPersistent="0" form="single" />
		</Variables>
		<Parameters>
			<Variable name="target" type="_wuid" values="" isPersistent="0" form="single" requirementType="In" />
		</Parameters>
		<Root OneTimeOnly="false" FailState="Recoverable" saveVersion="2">
			<Behavior canSkip="1">
				<Sequence>
					<IsFastForwarded failOnCondition="false" saveVersion="2">
						<Then canSkip="1">
							<EntityContextCheck context="combat_triggerSALSearchInDuelBehaviourUnarmed" target="" saveVersion="2">
								<Then canSkip="1">
									<Success />
								</Then>
								<Else canSkip="1">
									<EntityContextCheck context="combat_triggerSALSearchInDuelBehaviour" target="" saveVersion="2">
										<Then canSkip="1">
											<WaitAction />
										</Then>
										<Else canSkip="1">
											<EntityContextCheck context="combat_forceOversized" target="" saveVersion="2">
												<Then canSkip="1">
													<DrawAction WeaponSet="Oversized" fullBody="false" tags="" useSelectedWeaponSet="false" />
												</Then>
												<Else canSkip="1">
													<DrawAction WeaponSet="Primary" fullBody="false" tags="" useSelectedWeaponSet="false" />
												</Else>
											</EntityContextCheck>
										</Else>
									</EntityContextCheck>
								</Else>
							</EntityContextCheck>
						</Then>
					</IsFastForwarded>
					<AtomicDecorator>
						<Sequence>
							<GetScheduledPriority Priority="$priority" />
							<Expression expressions="$priority = $priority + 1" />
							<Function_callInterrupt_attack alreadyCriminal="false" assaultData="" defenceMode="false" escalatedFromFailedSurrender="false" freshlyAttributedCrime="false" ignorePriority="true" information="" initiator="$enum:switch_interruptInitiator.concept" previousReaction="$enum:crime_reactionKind.unknown" priority="$priority" questBehavior="true" relationOverride="true" stimulusKind="$enum:crime_stimulusKind.enemy" target="$target" nodeLabel="33986506" />
						</Sequence>
					</AtomicDecorator>
				</Sequence>
			</Behavior>
		</Root>
		<ForestContainer />
		<EditorData Signature="fightRepeated" EventSet="">
			<Variables>
				<Variable name="priority" comment="" />
				<Variable name="target" comment="" />
			</Variables>
			<ForwardDeclarations />
			<Root editorPosX="-220" editorPosY="20" hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
				<OutputBreakpoints />
				<Behavior>
					<Sequence hasInputBreakpoint="0" comment="" breakpointFlags="0">
						<OutputBreakpoints />
						<IsFastForwarded hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
							<OutputBreakpoints />
							<Then>
								<EntityContextCheck hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
									<OutputBreakpoints />
									<Then>
										<Success hasInputBreakpoint="0" comment="FF action will be triggered in interruptAttack by CombatAction, UNARMED" breakpointFlags="0">
											<OutputBreakpoints />
										</Success>
									</Then>
									<Else>
										<EntityContextCheck hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
											<OutputBreakpoints />
											<Then>
												<WaitAction hasInputBreakpoint="0" comment="" breakpointFlags="0">
													<OutputBreakpoints />
												</WaitAction>
											</Then>
											<Else>
												<EntityContextCheck hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
													<OutputBreakpoints />
													<Then>
														<DrawAction hasInputBreakpoint="0" comment="" breakpointFlags="0">
															<OutputBreakpoints />
														</DrawAction>
													</Then>
													<Else>
														<DrawAction hasInputBreakpoint="0" comment="" breakpointFlags="0">
															<OutputBreakpoints />
														</DrawAction>
													</Else>
												</EntityContextCheck>
											</Else>
										</EntityContextCheck>
									</Else>
								</EntityContextCheck>
							</Then>
						</IsFastForwarded>
						<AtomicDecorator hasInputBreakpoint="0" comment="" breakpointFlags="0">
							<OutputBreakpoints />
							<Sequence hasInputBreakpoint="0" comment="" breakpointFlags="0">
								<OutputBreakpoints />
								<GetScheduledPriority hasInputBreakpoint="0" comment="" breakpointFlags="0">
									<OutputBreakpoints />
								</GetScheduledPriority>
								<Expression hasInputBreakpoint="0" comment="" breakpointFlags="0">
									<OutputBreakpoints />
								</Expression>
								<Function_callInterrupt_attack hasInputBreakpoint="0" comment="" breakpointFlags="0">
									<OutputBreakpoints />
								</Function_callInterrupt_attack>
							</Sequence>
						</AtomicDecorator>
					</Sequence>
				</Behavior>
			</Root>
			<Forest />
			<Comments />
		</EditorData>
	</BehaviorTree>
	<BehaviorTree name="combat_fightInQuestSkirmish" is_function="0">
		<Variables>
			<Variable name="aliveFriendFound" type="_bool" values="" isPersistent="0" form="single" />
			<Variable name="alreadyFled" type="_bool" values="" isPersistent="0" form="single" />
			<Variable name="myFriend" type="_wuid" values="" isPersistent="0" form="single" />
			<Variable name="playerFled" type="_bool" values="" isPersistent="0" form="single" />
			<Variable name="priority" type="_int" values="" isPersistent="0" form="single" />
			<Variable name="questFightStatus" type="combat:questFightStatus" values="" isPersistent="0" form="single" />
			<Variable name="skirmishFriends" type="_wuid" values="" isPersistent="0" form="array" />
		</Variables>
		<Parameters>
			<Variable name="target" type="_wuid" values="" isPersistent="0" form="single" requirementType="In" />
		</Parameters>
		<Root OneTimeOnly="false" FailState="Recoverable" saveVersion="2">
			<Behavior canSkip="1">
				<Sequence>
					<IsDeadCheck SoulWUID="$target" FailSubtMissing="false" saveVersion="2">
						<Then canSkip="1">
							<Sequence>
								<GraphSearch Origin="$target" Borders="" depth="1" selection="true" SearchPattern="Depth" EdgePruning="&apos;parent,inventory&apos;" AllowedEdges="" SubGraph="" AllowSubtraph="false" includeOrigin="false" excludeOrigin="false" failOnEmpty="true" SetOperationChoice="Intersection|And" errorOnEmpty="false" shortCircuit="false" skipTraversed="true">
									<LinkTagFilter tag="&apos;skirmish_concept_friend&apos;" prune="true" negprune="unknown" Parent="" Child="" Data="" />
									<Nodalyzer Quantifiers="ForAll" Parent="" Child="$skirmishFriends" saveVersion="2" />
								</GraphSearch>
								<ForEach startIndex="0" step="1" array="$skirmishFriends" iterator="" value="$myFriend" break="$aliveFriendFound">
									<IsDeadCheck SoulWUID="$myFriend" FailSubtMissing="false" saveVersion="2">
										<Else canSkip="1">
											<Expression expressions="$aliveFriendFound = true &#10;$target = $myFriend" />
										</Else>
									</IsDeadCheck>
								</ForEach>
							</Sequence>
						</Then>
					</IsDeadCheck>
					<EntityContextCheck context="combat_triggerSALSearchInDuelBehaviour" target="" saveVersion="2">
						<Then canSkip="1">
							<DrawAction WeaponSet="Primary" fullBody="false" tags="" useSelectedWeaponSet="false" />
						</Then>
					</EntityContextCheck>
					<EntityContextCheck context="combat_triggerSALSearchInDuelBehaviourUnarmed" target="" saveVersion="2">
						<Then canSkip="1">
							<WaitAction />
						</Then>
					</EntityContextCheck>
					<EntityContextCheck context="crime_isCombatableAnimal" target="" saveVersion="2">
						<Then canSkip="1">
							<Sequence>
								<Function_callInterrupt_animal_attack ignorePriority="false" initiator="$enum:switch_interruptInitiator.concept" previousReaction="$enum:crime_animal_reactionKind.unknown" skirmishRelationOverride="$enum:skirmishRelationOverride.none" stimulusKind="$enum:crime_animal_stimulusKind.unknown" target="$target" nodeLabel="33497547" />
							</Sequence>
						</Then>
						<Else canSkip="1">
							<Sequence>
								<SuppressFailure>
									<Sequence>
										<GraphSearch Origin="$this.id" Borders="" depth="1" selection="true" SearchPattern="Depth" EdgePruning="&apos;parent,inventory&apos;" AllowedEdges="" SubGraph="" AllowSubtraph="false" includeOrigin="false" excludeOrigin="false" failOnEmpty="true" SetOperationChoice="Intersection|And" errorOnEmpty="false" shortCircuit="false" skipTraversed="true">
											<LinkTagFilter tag="&apos;combat_questFightStatus&apos;" prune="true" negprune="unknown" Parent="" Child="" Data="" />
											<Datalyzer Tag="&apos;combat_questFightStatus&apos;" Quantifiers="ForAll" Parent="" Child="" Data="$questFightStatus" saveVersion="2" />
										</GraphSearch>
										<IfCondition failOnCondition="false" condition="$questFightStatus.status == $enum:combat_questFightStatus.fled">
											<Expression expressions="$alreadyFled = true" />
										</IfCondition>
									</Sequence>
								</SuppressFailure>
								<IfCondition failOnCondition="false" condition="$target == $__player">
									<IsFastForwarded failOnCondition="false" saveVersion="2">
										<Then canSkip="1">
											<Success />
										</Then>
										<Else canSkip="1">
											<RecentlySkirmished NPC1="$this.id" NPC2="$__player" MaxTime="600" saveVersion="2">
												<Then canSkip="1">
													<DistanceCondition Origin="$this.id" ReferencePt="$__player" Low="35.000000" High="35.000000" Negation="true" ValueOnMiddle="false" failOnCondition="false">
														<Expression expressions="$playerFled = true" />
													</DistanceCondition>
												</Then>
												<Else canSkip="1">
													<Success />
												</Else>
											</RecentlySkirmished>
										</Else>
									</IsFastForwarded>
								</IfCondition>
								<IfElseCondition failOnCondition="false" condition="$playerFled" saveVersion="2">
									<Then canSkip="1">
										<Wait duration="&apos;15s&apos;" timeType="GameTime" doFail="false" variation="" />
									</Then>
									<Else canSkip="1">
										<IfElseCondition failOnCondition="false" condition="$alreadyFled" saveVersion="2">
											<Then canSkip="1">
												<Sequence>
													<EntityContextBarrier context="combat_fightInQuestSkirmish" target="" Negation="false" RunLogic="Halt">
														<Wait duration="&apos;-1&apos;" timeType="GameTime" doFail="false" variation="" />
													</EntityContextBarrier>
													<RemoveLink From="$this.id" To="$this.id" Tag="&apos;alreadyFledFromSkirmish&apos;" LinkOpHandleMode="Success" />
												</Sequence>
											</Then>
											<Else canSkip="1">
												<Sequence>
													<Expression expressions="$priority = 160" />
													<Function_callInterrupt_attack assaultData="" criminalFreshness="$enum:crime_criminalFreshness.unknown" defenceMode="false" escalatedFromFailedSurrender="false" freshlyAttributedCrime="false" ignorePriority="true" information="" initiator="$enum:switch_interruptInitiator.concept" previousReaction="$enum:crime_reactionKind.unknown" priority="$priority" questBehavior="true" relationOverride="true" stimulusKind="$enum:crime_stimulusKind.enemy" target="$target" nodeLabel="21838610" />
												</Sequence>
											</Else>
										</IfElseCondition>
									</Else>
								</IfElseCondition>
							</Sequence>
						</Else>
					</EntityContextCheck>
				</Sequence>
			</Behavior>
		</Root>
		<ForestContainer />
		<EditorData Signature="combat_fightInQuestSkirmish" EventSet="">
			<Variables>
				<Variable name="aliveFriendFound" comment="" />
				<Variable name="alreadyFled" comment="" />
				<Variable name="myFriend" comment="" />
				<Variable name="playerFled" comment="" />
				<Variable name="priority" comment="" />
				<Variable name="questFightStatus" comment="" />
				<Variable name="skirmishFriends" comment="" />
				<Variable name="target" comment="" />
			</Variables>
			<ForwardDeclarations />
			<Root editorPosX="-350" editorPosY="50" hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
				<OutputBreakpoints />
				<Behavior>
					<Sequence hasInputBreakpoint="0" comment="" breakpointFlags="0">
						<OutputBreakpoints />
						<IsDeadCheck hasInputBreakpoint="0" comment="KCD2-142111" breakpointFlags="0" saveVersion="2">
							<OutputBreakpoints />
							<Then>
								<Sequence hasInputBreakpoint="0" comment="" breakpointFlags="0">
									<OutputBreakpoints />
									<GraphSearch hasInputBreakpoint="0" comment="" breakpointFlags="0">
										<OutputBreakpoints />
										<LinkTagFilter hasInputBreakpoint="0" comment="" breakpointFlags="0">
											<OutputBreakpoints />
										</LinkTagFilter>
										<Nodalyzer hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
											<OutputBreakpoints />
										</Nodalyzer>
									</GraphSearch>
									<ForEach hasInputBreakpoint="0" comment="" breakpointFlags="0">
										<OutputBreakpoints />
										<IsDeadCheck hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
											<OutputBreakpoints />
											<Else>
												<Expression hasInputBreakpoint="0" comment="" breakpointFlags="0">
													<OutputBreakpoints />
												</Expression>
											</Else>
										</IsDeadCheck>
									</ForEach>
								</Sequence>
							</Then>
						</IsDeadCheck>
						<EntityContextCheck hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
							<OutputBreakpoints />
							<Then>
								<DrawAction hasInputBreakpoint="0" comment="" breakpointFlags="0">
									<OutputBreakpoints />
								</DrawAction>
							</Then>
						</EntityContextCheck>
						<EntityContextCheck hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
							<OutputBreakpoints />
							<Then>
								<WaitAction hasInputBreakpoint="0" comment="" breakpointFlags="0">
									<OutputBreakpoints />
								</WaitAction>
							</Then>
						</EntityContextCheck>
						<EntityContextCheck hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
							<OutputBreakpoints />
							<Then>
								<Sequence hasInputBreakpoint="0" comment="" breakpointFlags="0">
									<OutputBreakpoints />
									<Function_callInterrupt_animal_attack hasInputBreakpoint="0" comment="" breakpointFlags="0">
										<OutputBreakpoints />
									</Function_callInterrupt_animal_attack>
								</Sequence>
							</Then>
							<Else>
								<Sequence hasInputBreakpoint="0" comment="" breakpointFlags="0">
									<OutputBreakpoints />
									<SuppressFailure hasInputBreakpoint="0" comment="" breakpointFlags="0">
										<OutputBreakpoints />
										<Sequence hasInputBreakpoint="0" comment="" breakpointFlags="0">
											<OutputBreakpoints />
											<GraphSearch hasInputBreakpoint="0" comment="" breakpointFlags="0">
												<OutputBreakpoints />
												<LinkTagFilter hasInputBreakpoint="0" comment="" breakpointFlags="0">
													<OutputBreakpoints />
												</LinkTagFilter>
												<Datalyzer hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
													<OutputBreakpoints />
												</Datalyzer>
											</GraphSearch>
											<IfCondition hasInputBreakpoint="0" comment="" breakpointFlags="0">
												<OutputBreakpoints />
												<Expression hasInputBreakpoint="0" comment="" breakpointFlags="0">
													<OutputBreakpoints />
												</Expression>
											</IfCondition>
										</Sequence>
									</SuppressFailure>
									<IfCondition hasInputBreakpoint="0" comment="" breakpointFlags="0">
										<OutputBreakpoints />
										<IsFastForwarded hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
											<OutputBreakpoints />
											<Then>
												<Success hasInputBreakpoint="0" comment="" breakpointFlags="0">
													<OutputBreakpoints />
												</Success>
											</Then>
											<Else>
												<RecentlySkirmished hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
													<OutputBreakpoints />
													<Then>
														<DistanceCondition hasInputBreakpoint="0" comment="" breakpointFlags="0">
															<OutputBreakpoints />
															<Expression hasInputBreakpoint="0" comment="" breakpointFlags="0">
																<OutputBreakpoints />
															</Expression>
														</DistanceCondition>
													</Then>
													<Else>
														<Success hasInputBreakpoint="0" comment="" breakpointFlags="0">
															<OutputBreakpoints />
														</Success>
													</Else>
												</RecentlySkirmished>
											</Else>
										</IsFastForwarded>
									</IfCondition>
									<IfElseCondition hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
										<OutputBreakpoints />
										<Then>
											<Wait hasInputBreakpoint="0" comment="" breakpointFlags="0">
												<OutputBreakpoints />
											</Wait>
										</Then>
										<Else>
											<IfElseCondition hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
												<OutputBreakpoints />
												<Then>
													<Sequence hasInputBreakpoint="0" comment="" breakpointFlags="0">
														<OutputBreakpoints />
														<EntityContextBarrier hasInputBreakpoint="0" comment="" breakpointFlags="0">
															<OutputBreakpoints />
															<Wait hasInputBreakpoint="0" comment="" breakpointFlags="0">
																<OutputBreakpoints />
															</Wait>
														</EntityContextBarrier>
														<RemoveLink hasInputBreakpoint="0" comment="" breakpointFlags="0">
															<OutputBreakpoints />
														</RemoveLink>
													</Sequence>
												</Then>
												<Else>
													<Sequence hasInputBreakpoint="0" comment="" breakpointFlags="0">
														<OutputBreakpoints />
														<Expression hasInputBreakpoint="0" comment="" breakpointFlags="0">
															<OutputBreakpoints />
														</Expression>
														<Function_callInterrupt_attack hasInputBreakpoint="0" comment="" breakpointFlags="0">
															<OutputBreakpoints />
														</Function_callInterrupt_attack>
													</Sequence>
												</Else>
											</IfElseCondition>
										</Else>
									</IfElseCondition>
								</Sequence>
							</Else>
						</EntityContextCheck>
					</Sequence>
				</Behavior>
			</Root>
			<Forest />
			<Comments />
		</EditorData>
	</BehaviorTree>
	<BehaviorTree name="leaveLevelObsolete" is_function="1">
		<Variables>
			<Variable name="levelExits" type="_wuid" values="" isPersistent="0" form="array" />
			<Variable name="notSeenByPlayer" type="_bool" values="" isPersistent="0" form="single" />
			<Variable name="speed" type="enum:movementSpeed" values="$enum:movementSpeed.walk" isPersistent="0" form="single" />
			<Variable name="t_distanceMove_params" type="distanceMove_params:wuid" values="" isPersistent="0" form="single" />
		</Variables>
		<Parameters>
			<Variable name="speedString" type="_string" values="&apos;Walk&apos;" isPersistent="0" form="single" requirementType="In" />
			<Variable name="streamed" type="_bool" values="" isPersistent="0" form="single" requirementType="In" />
		</Parameters>
		<Root OneTimeOnly="false" FailState="Recoverable" saveVersion="2">
			<Behavior canSkip="1">
				<Sequence>
					<GraphSearch Origin="$__land" Borders="" depth="1" selection="true" SearchPattern="Depth" EdgePruning="&apos;parent,inventory&apos;" AllowedEdges="" SubGraph="" AllowSubtraph="false" includeOrigin="false" excludeOrigin="false" failOnEmpty="true" SetOperationChoice="Intersection|And" errorOnEmpty="false" shortCircuit="false" skipTraversed="true">
						<CategoryFilter categories="&apos;levelExit&apos;" Source="Child" prune="true" negprune="unknown" Parent="" Child="" />
						<Nodalyzer Quantifiers="ForAll" Parent="" Child="$levelExits" saveVersion="2">
							<Child0 canSkip="1">
								<RangeSorter point="$this.id" SortOrder="Ascending" Source="Child" />
							</Child0>
						</Nodalyzer>
					</GraphSearch>
					<Parallel successMode="Any" failureMode="Any">
						<While doFail="false" propagateChildFail="false" condition="true">
							<Sequence>
								<NotSeenByPlayer target="$this.id" timespan="&apos;2m&apos;" result="$notSeenByPlayer" />
								<IfElseCondition failOnCondition="false" condition="$notSeenByPlayer" saveVersion="2">
									<Then canSkip="1">
										<DistanceCondition Origin="$this.id" ReferencePt="$__player" Low="0.000000" High="40.000000" Negation="true" ValueOnMiddle="false" failOnCondition="false">
											<FuseBox StatusPropagation="Child" OneCleanup="false" saveVersion="2">
												<Child canSkip="1">
													<InstantCallback_empty EventName="&apos;OnDespawn&apos;" />
												</Child>
												<OnSuccess canSkip="1">
													<FuseBox StatusPropagation="Child" OneCleanup="false" saveVersion="2">
														<Child canSkip="1">
															<Function_leaveLevel_despawn nodeLabel="62485269" />
														</Child>
														<OnFail canSkip="1">
															<InstantCallback_empty EventName="&apos;DespawnFailed&apos;" />
														</OnFail>
													</FuseBox>
												</OnSuccess>
											</FuseBox>
										</DistanceCondition>
									</Then>
									<Else canSkip="1">
										<Wait duration="&apos;2500ms&apos;" timeType="GameTime" doFail="false" variation="" skipInLOD="false" />
									</Else>
								</IfElseCondition>
							</Sequence>
						</While>
						<Sequence>
							<Function_distanceMove initialSpeed="$speedString" outsideAreaOnly="false" stopDistanceVariation="0.000000" stopWithinDistance="0.500000" target="$levelExits[0]" useExactMove="false" useSituations="true" nodeLabel="40081573" />
							<Wait duration="&apos;-1&apos;" timeType="GameTime" doFail="false" variation="" skipInLOD="false" />
						</Sequence>
					</Parallel>
				</Sequence>
			</Behavior>
		</Root>
		<ForestContainer />
		<EditorData Signature="leaveLevelObsolete" EventSet="leaveLevelObsolete">
			<Variables>
				<Variable name="levelExits" comment="" />
				<Variable name="notSeenByPlayer" comment="" />
				<Variable name="speed" comment="" />
				<Variable name="t_distanceMove_params" comment="" />
				<Variable name="speedString" comment="" />
				<Variable name="streamed" comment="" />
			</Variables>
			<ForwardDeclarations />
			<Root editorPosX="-40" editorPosY="-260" hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
				<OutputBreakpoints />
				<Behavior>
					<Sequence hasInputBreakpoint="0" comment="" breakpointFlags="0">
						<OutputBreakpoints />
						<GraphSearch hasInputBreakpoint="0" comment="" breakpointFlags="0">
							<OutputBreakpoints />
							<CategoryFilter hasInputBreakpoint="0" comment="" breakpointFlags="0">
								<OutputBreakpoints />
							</CategoryFilter>
							<Nodalyzer hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
								<OutputBreakpoints />
								<Child0>
									<RangeSorter hasInputBreakpoint="0" comment="" breakpointFlags="0">
										<OutputBreakpoints />
									</RangeSorter>
								</Child0>
							</Nodalyzer>
						</GraphSearch>
						<Parallel hasInputBreakpoint="0" comment="" breakpointFlags="0">
							<OutputBreakpoints />
							<While hasInputBreakpoint="0" comment="" breakpointFlags="0">
								<OutputBreakpoints />
								<Sequence hasInputBreakpoint="0" comment="" breakpointFlags="0">
									<OutputBreakpoints />
									<NotSeenByPlayer hasInputBreakpoint="0" comment="" breakpointFlags="0">
										<OutputBreakpoints />
									</NotSeenByPlayer>
									<IfElseCondition hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
										<OutputBreakpoints />
										<Then>
											<DistanceCondition hasInputBreakpoint="0" comment="" breakpointFlags="0">
												<OutputBreakpoints />
												<FuseBox hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
													<OutputBreakpoints />
													<Child>
														<InstantCallback_empty hasInputBreakpoint="0" comment="" breakpointFlags="0">
															<OutputBreakpoints />
														</InstantCallback_empty>
													</Child>
													<OnSuccess>
														<FuseBox hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
															<OutputBreakpoints />
															<Child>
																<Function_leaveLevel_despawn hasInputBreakpoint="0" comment="" breakpointFlags="0">
																	<OutputBreakpoints />
																</Function_leaveLevel_despawn>
															</Child>
															<OnFail>
																<InstantCallback_empty hasInputBreakpoint="0" comment="" breakpointFlags="0">
																	<OutputBreakpoints />
																</InstantCallback_empty>
															</OnFail>
														</FuseBox>
													</OnSuccess>
												</FuseBox>
											</DistanceCondition>
										</Then>
										<Else>
											<Wait hasInputBreakpoint="0" comment="" breakpointFlags="0">
												<OutputBreakpoints />
											</Wait>
										</Else>
									</IfElseCondition>
								</Sequence>
							</While>
							<Sequence hasInputBreakpoint="0" comment="" breakpointFlags="0">
								<OutputBreakpoints />
								<Function_distanceMove hasInputBreakpoint="0" comment="" breakpointFlags="0">
									<OutputBreakpoints />
								</Function_distanceMove>
								<Wait hasInputBreakpoint="0" comment="" breakpointFlags="0">
									<OutputBreakpoints />
								</Wait>
							</Sequence>
						</Parallel>
					</Sequence>
				</Behavior>
			</Root>
			<Forest />
			<Comments>
				<Comment text="Don&apos;t_forget_to_include_horse_dismount/despawn_in_this_function" posX="1890" posY="-400" width="587" height="147" resizeBorderWidth="240" resizeBorderHeight="120" color="0.65,0.65,0.65" author="barbora.vykypelova" />
			</Comments>
		</EditorData>
	</BehaviorTree>
	<BehaviorTree name="guardWait" is_function="0">
		<Variables />
		<Root OneTimeOnly="false" FailState="Recoverable" saveVersion="2">
			<Behavior canSkip="1">
				<EntityContext context="crime_isAuthorityOnDuty" target="">
					<EntityContext context="crime_canFriskPlayerBehavior" target="">
						<Sequence>
							<WaitAction />
							<Wait duration="&apos;-1&apos;" timeType="GameTime" doFail="false" variation="" />
						</Sequence>
					</EntityContext>
				</EntityContext>
			</Behavior>
		</Root>
		<ForestContainer />
		<EditorData EventSet="">
			<Variables />
			<ForwardDeclarations />
			<Root hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
				<OutputBreakpoints />
				<Behavior>
					<EntityContext hasInputBreakpoint="0" comment="" breakpointFlags="0">
						<OutputBreakpoints />
						<EntityContext hasInputBreakpoint="0" comment="" breakpointFlags="0">
							<OutputBreakpoints />
							<Sequence hasInputBreakpoint="0" comment="" breakpointFlags="0">
								<OutputBreakpoints />
								<WaitAction hasInputBreakpoint="0" comment="" breakpointFlags="0">
									<OutputBreakpoints />
								</WaitAction>
								<Wait hasInputBreakpoint="0" comment="" breakpointFlags="0">
									<OutputBreakpoints />
								</Wait>
							</Sequence>
						</EntityContext>
					</EntityContext>
				</Behavior>
			</Root>
			<Forest />
			<Comments />
		</EditorData>
	</BehaviorTree>
	<BehaviorTree name="holdingWait" is_function="0">
		<Variables />
		<Root OneTimeOnly="false" FailState="Recoverable" saveVersion="2">
			<Behavior canSkip="1">
				<AnyDecorator preset="crime_keepStateAndItems" enabled="true">
					<Sequence>
						<WaitAction />
						<Wait duration="&apos;-1&apos;" timeType="GameTime" doFail="false" variation="" />
					</Sequence>
				</AnyDecorator>
			</Behavior>
		</Root>
		<ForestContainer />
		<EditorData EventSet="">
			<Variables />
			<ForwardDeclarations />
			<Root hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
				<OutputBreakpoints />
				<Behavior>
					<AnyDecorator hasInputBreakpoint="0" comment="" breakpointFlags="0">
						<OutputBreakpoints />
						<Sequence hasInputBreakpoint="0" comment="" breakpointFlags="0">
							<OutputBreakpoints />
							<WaitAction hasInputBreakpoint="0" comment="" breakpointFlags="0">
								<OutputBreakpoints />
							</WaitAction>
							<Wait hasInputBreakpoint="0" comment="" breakpointFlags="0">
								<OutputBreakpoints />
							</Wait>
						</Sequence>
					</AnyDecorator>
				</Behavior>
			</Root>
			<Forest />
			<Comments />
		</EditorData>
	</BehaviorTree>
	<BehaviorTree name="teleportOnHorse" is_function="0">
		<Variables />
		<Parameters>
			<Variable name="applyHorseUsageElement" type="_bool" values="" isPersistent="0" form="single" requirementType="In" />
			<Variable name="destination" type="_wuid" values="" isPersistent="0" form="single" requirementType="In" />
			<Variable name="horse" type="_wuid" values="" isPersistent="0" form="single" requirementType="In" />
		</Parameters>
		<Root OneTimeOnly="false" FailState="Recoverable" saveVersion="2">
			<Behavior canSkip="1">
				<HorseUsageElement horse="$horse" decisionLabel="teleportOnHorse_horseUsage" useDecision="true" enabled="$applyHorseUsageElement" saveVersion="2">
					<Search canSkip="1">
						<Success />
					</Search>
					<Exec canSkip="1">
						<StanceElement smartObject="$horse" stance="horse" allowAny="false" enabled="true">
							<TeleportAction Position="$destination" EndInterruptOnActionStart="false" />
						</StanceElement>
					</Exec>
				</HorseUsageElement>
			</Behavior>
		</Root>
		<ForestContainer />
		<EditorData Signature="teleportOnHorse" EventSet="">
			<Variables>
				<Variable name="applyHorseUsageElement" comment="" />
				<Variable name="destination" comment="" />
				<Variable name="horse" comment="" />
			</Variables>
			<ForwardDeclarations />
			<Root hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
				<OutputBreakpoints />
				<Behavior>
					<HorseUsageElement hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
						<OutputBreakpoints />
						<Search>
							<Success hasInputBreakpoint="0" comment="" breakpointFlags="0">
								<OutputBreakpoints />
							</Success>
						</Search>
						<Exec>
							<StanceElement hasInputBreakpoint="0" comment="" breakpointFlags="0">
								<OutputBreakpoints />
								<TeleportAction hasInputBreakpoint="0" comment="" breakpointFlags="0">
									<OutputBreakpoints />
								</TeleportAction>
							</StanceElement>
						</Exec>
					</HorseUsageElement>
				</Behavior>
			</Root>
			<Forest />
			<Comments />
		</EditorData>
	</BehaviorTree>
	<BehaviorTree name="interrupt_player_waitAction" is_function="0">
		<Variables>
			<Variable name="anyDecoratorPreset" type="_string" values="" isPersistent="0" form="single" />
		</Variables>
		<Parameters>
			<Variable name="keepTorch" type="_bool" values="" isPersistent="0" form="single" requirementType="In" />
		</Parameters>
		<Root OneTimeOnly="false" FailState="Recoverable" saveVersion="2">
			<Behavior canSkip="1">
				<Sequence>
					<IfElseCondition failOnCondition="false" condition="$keepTorch" saveVersion="2">
						<Then canSkip="1">
							<IsTorchDrawn who="$this.id" saveVersion="2">
								<Then canSkip="1">
									<Expression expressions="$anyDecoratorPreset = &apos;crime_keepStateAndLeftHand&apos;" />
								</Then>
								<Else canSkip="1">
									<Expression expressions="$anyDecoratorPreset = &apos;crime_keepState&apos;" />
								</Else>
							</IsTorchDrawn>
						</Then>
						<Else canSkip="1">
							<Expression expressions="$anyDecoratorPreset = &apos;crime_keepState&apos;" />
						</Else>
					</IfElseCondition>
					<AnyDecorator preset="crime_keepStance" enabled="true">
						<AnyDecorator preset="$anyDecoratorPreset" enabled="true">
							<WaitAction />
						</AnyDecorator>
					</AnyDecorator>
				</Sequence>
			</Behavior>
		</Root>
		<ForestContainer />
		<EditorData Signature="player_waitAction" EventSet="">
			<Variables>
				<Variable name="anyDecoratorPreset" comment="" />
				<Variable name="keepTorch" comment="" />
			</Variables>
			<ForwardDeclarations />
			<Root hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
				<OutputBreakpoints />
				<Behavior>
					<Sequence hasInputBreakpoint="0" comment="" breakpointFlags="0">
						<OutputBreakpoints />
						<IfElseCondition hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
							<OutputBreakpoints />
							<Then>
								<IsTorchDrawn hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
									<OutputBreakpoints />
									<Then>
										<Expression hasInputBreakpoint="0" comment="" breakpointFlags="0">
											<OutputBreakpoints />
										</Expression>
									</Then>
									<Else>
										<Expression hasInputBreakpoint="0" comment="" breakpointFlags="0">
											<OutputBreakpoints />
										</Expression>
									</Else>
								</IsTorchDrawn>
							</Then>
							<Else>
								<Expression hasInputBreakpoint="0" comment="" breakpointFlags="0">
									<OutputBreakpoints />
								</Expression>
							</Else>
						</IfElseCondition>
						<AnyDecorator hasInputBreakpoint="0" comment="" breakpointFlags="0">
							<OutputBreakpoints />
							<AnyDecorator hasInputBreakpoint="0" comment="" breakpointFlags="0">
								<OutputBreakpoints />
								<WaitAction hasInputBreakpoint="0" comment="" breakpointFlags="0">
									<OutputBreakpoints />
								</WaitAction>
							</AnyDecorator>
						</AnyDecorator>
					</Sequence>
				</Behavior>
			</Root>
			<Forest />
			<Comments />
		</EditorData>
	</BehaviorTree>
	<BehaviorTree name="callInterrupt_player_waitAction" is_function="1">
		<Variables />
		<Parameters>
			<Variable name="keepTorch" type="_bool" values="true" isPersistent="0" form="single" requirementType="In" />
		</Parameters>
		<Root OneTimeOnly="false" FailState="Recoverable" saveVersion="2">
			<Behavior canSkip="1">
				<AddInterrupt_player_waitAction keepTorch="$keepTorch" equipTorchIfRequired="false" Target="$__player" Host="$__land" Behavior="&apos;interrupt_player_waitAction&apos;" Priority="10" IgnorePriorityOnPreviousInterrupt="false" urgency="Instant" Aliveness="Alive" Privileged="false" FastForward="false" />
			</Behavior>
		</Root>
		<ForestContainer />
		<EditorData EventSet="">
			<Variables>
				<Variable name="keepTorch" comment="" />
			</Variables>
			<ForwardDeclarations />
			<Root hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
				<OutputBreakpoints />
				<Behavior>
					<AddInterrupt_player_waitAction hasInputBreakpoint="0" comment="TODO: Add some options? Any decorators etc." breakpointFlags="0">
						<OutputBreakpoints />
					</AddInterrupt_player_waitAction>
				</Behavior>
			</Root>
			<Forest />
			<Comments />
		</EditorData>
	</BehaviorTree>
	<BehaviorTree name="interupt_turnToPlayerInIdleStance" is_function="0">
		<Variables />
		<Root OneTimeOnly="false" FailState="Recoverable" saveVersion="2">
			<Behavior canSkip="1">
				<ExactMove directionType="FromVariable" directionSpecification="$__player" animationTriggerDist="0.150000" precise="false" changeNPCState="true" fastForwardIncludesMove="true" destinationSpecification="$this.id" destinationSpecification2="" destinationSpecification3="" speed="Walk" additionalParams="" pathFindingParams="" staminaPolicy="" pathInfo="" AnimationToPlay="" AnimationContext="" />
			</Behavior>
		</Root>
		<ForestContainer>
			<Sequence>
				<WaitAction />
				<Turn target="$__player" align="false" />
			</Sequence>
		</ForestContainer>
		<EditorData EventSet="">
			<Variables />
			<ForwardDeclarations />
			<Root hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
				<OutputBreakpoints />
				<Behavior>
					<ExactMove hasInputBreakpoint="0" comment="" breakpointFlags="0">
						<OutputBreakpoints />
					</ExactMove>
				</Behavior>
			</Root>
			<Forest>
				<Sequence editorPosX="810" editorPosY="-100" hasInputBreakpoint="0" comment="" breakpointFlags="0">
					<OutputBreakpoints />
					<WaitAction hasInputBreakpoint="0" comment="" breakpointFlags="0">
						<OutputBreakpoints />
					</WaitAction>
					<Turn hasInputBreakpoint="0" comment="" breakpointFlags="0">
						<OutputBreakpoints />
					</Turn>
				</Sequence>
			</Forest>
			<Comments />
		</EditorData>
	</BehaviorTree>
	<BehaviorTree name="leaveLevel_move" is_function="1">
		<Variables>
			<Variable name="horse" type="_wuid" values="" isPersistent="0" form="single" />
			<Variable name="pathParams" type="pathFindingParams" values="" isPersistent="0" form="single" />
			<Variable name="playerHorse" type="_wuid" values="" isPersistent="0" form="single" />
		</Variables>
		<Parameters>
			<Variable name="destination" type="_wuid" values="" isPersistent="0" form="single" requirementType="In" />
			<Variable name="speed" type="enum:movementSpeed" values="$enum:movementSpeed.walk" isPersistent="0" form="single" requirementType="In" />
			<Variable name="usePaths" type="_bool" values="" isPersistent="0" form="single" requirementType="In" />
		</Parameters>
		<Root OneTimeOnly="false" FailState="Recoverable" saveVersion="2">
			<Behavior canSkip="1">
				<Sequence>
					<GraphSearch Origin="$this.id" Borders="" depth="1" selection="true" SearchPattern="Depth" EdgePruning="&apos;parent,inventory&apos;" AllowedEdges="" SubGraph="&apos;horse,event_dummyWandererHorse&apos;" AllowSubtraph="false" includeOrigin="false" excludeOrigin="false" failOnEmpty="false" SetOperationChoice="Intersection|And" errorOnEmpty="false" shortCircuit="false" skipTraversed="true">
						<AnyLinkFilter Source="Child" prune="true" negprune="unknown" Parent="" Child="" />
						<SoulIsAliveFilter Source="Child" prune="true" negprune="unknown" Parent="" Child="" />
						<NegationOp Results="true" Advance="true" EndOp="true" saveVersion="2">
							<Child0 canSkip="1">
								<LinkTagFilter tag="&apos;horseWasNotAvailable&apos;" prune="true" negprune="unknown" Parent="" Child="" Data="" />
							</Child0>
						</NegationOp>
						<Nodalyzer Quantifiers="Exists" Parent="" Child="$horse" saveVersion="2" />
					</GraphSearch>
					<Sequence>
						<GetPlayerHorse HorseWuid="$playerHorse" />
						<CheckWuidValid wuid="$playerHorse" FailSubtMissing="false" saveVersion="2">
							<Then canSkip="1">
								<IfCondition failOnCondition="false" condition="$playerHorse == $horse">
									<AddLink From="$this.id" To="$horse" Tag="&apos;horseWasNotAvailable&apos;" Data="" LinkOpHandleMode="OverWrite" />
								</IfCondition>
							</Then>
							<Else canSkip="1">
								<Success />
							</Else>
						</CheckWuidValid>
					</Sequence>
					<IfElseCondition failOnCondition="false" condition="$usePaths" saveVersion="2">
						<Then canSkip="1">
							<Expression expressions="$pathParams.usePaths = true" />
						</Then>
						<Else canSkip="1">
							<Expression expressions="$pathParams.usePaths = false" />
						</Else>
					</IfElseCondition>
					<Selector>
						<IfCondition failOnCondition="true" condition="$horse ~= $__null &amp; &#10;$playerHorse ~= $horse">
							<StanceCheck soul="$__player" stance="horse" smartObject="$horse" negate="false" failOnCondition="false" saveVersion="2">
								<Then canSkip="1">
									<Fail />
								</Then>
								<Else canSkip="1">
									<FuseBox StatusPropagation="Child" OneCleanup="false" saveVersion="2">
										<Child canSkip="1">
											<HorseUsageElement horse="$horse" decisionLabel="Label1" useDecision="true" enabled="true" saveVersion="2">
												<Search canSkip="1">
													<Success />
												</Search>
												<Exec canSkip="1">
													<StanceElement smartObject="$horse" stance="horse" allowAny="false" enabled="true">
														<Move stopWithinDistance="0.200000" stopDistanceVariation="0.100000" rayCasteFlee="false" successDistance="5.000000" changeNPCState="true" fastForwardIncludesMove="false" destinationSpecification="$destination" destinationSpecification2="" destinationSpecification3="" speed="$speed" additionalParams="" pathFindingParams="$pathParams" staminaPolicy="" pathInfo="" />
													</StanceElement>
												</Exec>
											</HorseUsageElement>
										</Child>
										<OnFail canSkip="1">
											<AddLink From="$this.id" To="$horse" Tag="&apos;horseWasNotAvailable&apos;" Data="" LinkOpHandleMode="OverWrite" />
										</OnFail>
									</FuseBox>
								</Else>
							</StanceCheck>
						</IfCondition>
						<Move stopWithinDistance="0.200000" stopDistanceVariation="0.100000" rayCasteFlee="false" successDistance="5.000000" changeNPCState="true" fastForwardIncludesMove="false" destinationSpecification="$destination" destinationSpecification2="" destinationSpecification3="" speed="$speed" additionalParams="" pathFindingParams="$pathParams" staminaPolicy="" pathInfo="" />
					</Selector>
				</Sequence>
			</Behavior>
		</Root>
		<ForestContainer>
			<Sequence>
				<FuseBox StatusPropagation="Child" OneCleanup="false" saveVersion="2">
					<Child canSkip="1">
						<StanceElement smartObject="$horse" stance="horse" allowAny="false" enabled="true">
							<Move stopWithinDistance="0.200000" stopDistanceVariation="0.100000" rayCasteFlee="false" successDistance="5.000000" changeNPCState="true" fastForwardIncludesMove="false" destinationSpecification="$destination" destinationSpecification2="" destinationSpecification3="" speed="$speed" additionalParams="" pathFindingParams="$pathParams" staminaPolicy="" pathInfo="" />
						</StanceElement>
					</Child>
				</FuseBox>
			</Sequence>
			<SuppressFailure />
		</ForestContainer>
		<EditorData EventSet="">
			<Variables>
				<Variable name="horse" comment="" />
				<Variable name="pathParams" comment="" />
				<Variable name="playerHorse" comment="" />
				<Variable name="destination" comment="" />
				<Variable name="speed" comment="" />
				<Variable name="usePaths" comment="" />
			</Variables>
			<ForwardDeclarations />
			<Root hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
				<OutputBreakpoints />
				<Behavior>
					<Sequence hasInputBreakpoint="0" comment="" breakpointFlags="0">
						<OutputBreakpoints />
						<GraphSearch hasInputBreakpoint="0" comment="" breakpointFlags="0">
							<OutputBreakpoints />
							<AnyLinkFilter hasInputBreakpoint="0" comment="" breakpointFlags="0">
								<OutputBreakpoints />
							</AnyLinkFilter>
							<SoulIsAliveFilter hasInputBreakpoint="0" comment="" breakpointFlags="0">
								<OutputBreakpoints />
							</SoulIsAliveFilter>
							<NegationOp hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
								<OutputBreakpoints />
								<Child0>
									<LinkTagFilter hasInputBreakpoint="0" comment="" breakpointFlags="0">
										<OutputBreakpoints />
									</LinkTagFilter>
								</Child0>
							</NegationOp>
							<Nodalyzer hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
								<OutputBreakpoints />
							</Nodalyzer>
						</GraphSearch>
						<Sequence hasInputBreakpoint="0" comment="" breakpointFlags="0">
							<OutputBreakpoints />
							<GetPlayerHorse hasInputBreakpoint="0" comment="" breakpointFlags="0">
								<OutputBreakpoints />
							</GetPlayerHorse>
							<CheckWuidValid hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
								<OutputBreakpoints />
								<Then>
									<IfCondition hasInputBreakpoint="0" comment="" breakpointFlags="0">
										<OutputBreakpoints />
										<AddLink hasInputBreakpoint="0" comment="" breakpointFlags="0">
											<OutputBreakpoints />
										</AddLink>
									</IfCondition>
								</Then>
								<Else>
									<Success hasInputBreakpoint="0" comment="" breakpointFlags="0">
										<OutputBreakpoints />
									</Success>
								</Else>
							</CheckWuidValid>
						</Sequence>
						<IfElseCondition hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
							<OutputBreakpoints />
							<Then>
								<Expression hasInputBreakpoint="0" comment="" breakpointFlags="0">
									<OutputBreakpoints />
								</Expression>
							</Then>
							<Else>
								<Expression hasInputBreakpoint="0" comment="" breakpointFlags="0">
									<OutputBreakpoints />
								</Expression>
							</Else>
						</IfElseCondition>
						<Selector hasInputBreakpoint="0" comment="" breakpointFlags="0">
							<OutputBreakpoints />
							<IfCondition hasInputBreakpoint="0" comment="" breakpointFlags="0">
								<OutputBreakpoints />
								<StanceCheck hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
									<OutputBreakpoints />
									<Then>
										<Fail hasInputBreakpoint="0" comment="" breakpointFlags="0">
											<OutputBreakpoints />
										</Fail>
									</Then>
									<Else>
										<FuseBox hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
											<OutputBreakpoints />
											<Child>
												<HorseUsageElement hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
													<OutputBreakpoints />
													<Search>
														<Success hasInputBreakpoint="0" comment="" breakpointFlags="0">
															<OutputBreakpoints />
														</Success>
													</Search>
													<Exec>
														<StanceElement hasInputBreakpoint="0" comment="" breakpointFlags="0">
															<OutputBreakpoints />
															<Move hasInputBreakpoint="0" comment="" breakpointFlags="0">
																<OutputBreakpoints />
															</Move>
														</StanceElement>
													</Exec>
												</HorseUsageElement>
											</Child>
											<OnFail>
												<AddLink hasInputBreakpoint="0" comment="" breakpointFlags="0">
													<OutputBreakpoints />
												</AddLink>
											</OnFail>
										</FuseBox>
									</Else>
								</StanceCheck>
							</IfCondition>
							<Move hasInputBreakpoint="0" comment="" breakpointFlags="0">
								<OutputBreakpoints />
							</Move>
						</Selector>
					</Sequence>
				</Behavior>
			</Root>
			<Forest>
				<Sequence editorPosX="1590" editorPosY="710" hasInputBreakpoint="0" comment="" breakpointFlags="0">
					<OutputBreakpoints />
					<FuseBox hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
						<OutputBreakpoints />
						<Child>
							<StanceElement hasInputBreakpoint="0" comment="" breakpointFlags="0">
								<OutputBreakpoints />
								<Move hasInputBreakpoint="0" comment="" breakpointFlags="0">
									<OutputBreakpoints />
								</Move>
							</StanceElement>
						</Child>
					</FuseBox>
				</Sequence>
				<SuppressFailure editorPosX="1660" editorPosY="160" hasInputBreakpoint="0" comment="When interrupted here, don&apos;t draw the link" breakpointFlags="0">
					<OutputBreakpoints />
				</SuppressFailure>
			</Forest>
			<Comments />
		</EditorData>
	</BehaviorTree>
	<BehaviorTree name="recoveringDeadBody" is_function="0">
		<Variables />
		<Parameters>
			<Variable name="destination" type="_wuid" values="" isPersistent="0" form="single" requirementType="In" />
		</Parameters>
		<Root OneTimeOnly="false" FailState="Recoverable" saveVersion="2">
			<Behavior canSkip="1">
				<EntityContext context="deadBody_allowActorAnimsForDeadNPC" target="">
					<Sequence>
						<TeleportAction Position="$destination" EndInterruptOnActionStart="false" />
						<SuppressFailure>
							<AnimationAction fragment="&apos;DeadBody_Ragdoll&apos;" tags="" eventReferenceObject="" alignObject="" slaveObject="" resourceOverride="" allowTorchForPlayer="false" />
						</SuppressFailure>
					</Sequence>
				</EntityContext>
			</Behavior>
		</Root>
		<ForestContainer />
		<EditorData Signature="teleport" EventSet="">
			<Variables>
				<Variable name="destination" comment="" />
			</Variables>
			<ForwardDeclarations />
			<Root hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
				<OutputBreakpoints />
				<Behavior>
					<EntityContext hasInputBreakpoint="0" comment="" breakpointFlags="0">
						<OutputBreakpoints />
						<Sequence hasInputBreakpoint="0" comment="" breakpointFlags="0">
							<OutputBreakpoints />
							<TeleportAction hasInputBreakpoint="0" comment="" breakpointFlags="0">
								<OutputBreakpoints />
							</TeleportAction>
							<SuppressFailure hasInputBreakpoint="0" comment="" breakpointFlags="0">
								<OutputBreakpoints />
								<AnimationAction hasInputBreakpoint="0" comment="" breakpointFlags="0">
									<OutputBreakpoints />
								</AnimationAction>
							</SuppressFailure>
						</Sequence>
					</EntityContext>
				</Behavior>
			</Root>
			<Forest />
			<Comments />
		</EditorData>
	</BehaviorTree>
	<BehaviorTree name="testTeleport" is_function="0">
		<Variables>
			<Variable name="horse" type="_wuid" values="" isPersistent="0" form="single" />
		</Variables>
		<Parameters>
			<Variable name="keepHorse" type="_bool" values="false" isPersistent="0" form="single" requirementType="In" />
			<Variable name="position" type="vec3" values="" isPersistent="0" form="single" requirementType="In" />
		</Parameters>
		<Root OneTimeOnly="false" FailState="Recoverable" saveVersion="2">
			<Behavior canSkip="1">
				<AnyDecorator preset="crime_keepItems" enabled="true">
					<AnyDecorator preset="teleport_keepClothes" enabled="true">
						<IfElseCondition failOnCondition="false" condition="$keepHorse" saveVersion="2">
							<Then canSkip="1">
								<Selector>
									<Sequence>
										<GraphSearch Origin="$this.id" Borders="" depth="1" selection="true" SearchPattern="Depth" EdgePruning="&apos;parent,inventory&apos;" AllowedEdges="" SubGraph="" AllowSubtraph="false" includeOrigin="false" excludeOrigin="false" failOnEmpty="true" SetOperationChoice="Intersection|And" errorOnEmpty="false" shortCircuit="false" skipTraversed="true">
											<LinkTagFilter tag="&apos;mount&apos;" prune="true" negprune="unknown" Parent="" Child="$horse" Data="" />
										</GraphSearch>
										<HorseUsageElement horse="$horse" decisionLabel="teleportOnHorse_horseUsage" useDecision="true" enabled="false" saveVersion="2">
											<Search canSkip="1">
												<Success />
											</Search>
											<Exec canSkip="1">
												<StanceElement smartObject="$horse" stance="horse" allowAny="false" enabled="true">
													<TeleportAction Position="$position" EndInterruptOnActionStart="true" />
												</StanceElement>
											</Exec>
										</HorseUsageElement>
									</Sequence>
									<TeleportAction Position="$position" EndInterruptOnActionStart="true" />
								</Selector>
							</Then>
							<Else canSkip="1">
								<TeleportAction Position="$position" EndInterruptOnActionStart="true" />
							</Else>
						</IfElseCondition>
					</AnyDecorator>
				</AnyDecorator>
			</Behavior>
		</Root>
		<ForestContainer />
		<EditorData EventSet="">
			<Variables>
				<Variable name="horse" comment="" />
				<Variable name="keepHorse" comment="" />
				<Variable name="position" comment="" />
			</Variables>
			<ForwardDeclarations />
			<Root hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
				<OutputBreakpoints />
				<Behavior>
					<AnyDecorator hasInputBreakpoint="0" comment="" breakpointFlags="0">
						<OutputBreakpoints />
						<AnyDecorator hasInputBreakpoint="0" comment="" breakpointFlags="0">
							<OutputBreakpoints />
							<IfElseCondition hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
								<OutputBreakpoints />
								<Then>
									<Selector hasInputBreakpoint="0" comment="" breakpointFlags="0">
										<OutputBreakpoints />
										<Sequence hasInputBreakpoint="0" comment="" breakpointFlags="0">
											<OutputBreakpoints />
											<GraphSearch hasInputBreakpoint="0" comment="" breakpointFlags="0">
												<OutputBreakpoints />
												<LinkTagFilter hasInputBreakpoint="0" comment="" breakpointFlags="0">
													<OutputBreakpoints />
												</LinkTagFilter>
											</GraphSearch>
											<HorseUsageElement hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
												<OutputBreakpoints />
												<Search>
													<Success hasInputBreakpoint="0" comment="" breakpointFlags="0">
														<OutputBreakpoints />
													</Success>
												</Search>
												<Exec>
													<StanceElement hasInputBreakpoint="0" comment="" breakpointFlags="0">
														<OutputBreakpoints />
														<TeleportAction hasInputBreakpoint="0" comment="" breakpointFlags="0">
															<OutputBreakpoints />
														</TeleportAction>
													</StanceElement>
												</Exec>
											</HorseUsageElement>
										</Sequence>
										<TeleportAction hasInputBreakpoint="0" comment="" breakpointFlags="0">
											<OutputBreakpoints />
										</TeleportAction>
									</Selector>
								</Then>
								<Else>
									<TeleportAction hasInputBreakpoint="0" comment="" breakpointFlags="0">
										<OutputBreakpoints />
									</TeleportAction>
								</Else>
							</IfElseCondition>
						</AnyDecorator>
					</AnyDecorator>
				</Behavior>
			</Root>
			<Forest />
			<Comments />
		</EditorData>
	</BehaviorTree>
	<BehaviorTree name="teleportHorseToPlayer" is_function="1">
		<Variables />
		<Parameters>
			<Variable name="moveToPlayer" type="_bool" values="false" isPersistent="0" form="single" requirementType="In" />
			<Variable name="teleportTarget" type="transform" values="" isPersistent="0" form="single" requirementType="In" />
		</Parameters>
		<Root OneTimeOnly="false" FailState="Recoverable" saveVersion="2">
			<Behavior canSkip="1">
				<Sequence>
					<TeleportAction Position="$teleportTarget" EndInterruptOnActionStart="true" />
					<IfCondition failOnCondition="false" condition="$moveToPlayer == true">
						<InstantSendMessageToNPC target="$this.id" type="&apos;horseModule:playerCommand&apos;" values="$enum:HorseCommands.ComeToMe" />
					</IfCondition>
				</Sequence>
			</Behavior>
		</Root>
		<ForestContainer />
		<EditorData EventSet="">
			<Variables>
				<Variable name="moveToPlayer" comment="" />
				<Variable name="teleportTarget" comment="" />
			</Variables>
			<ForwardDeclarations />
			<Root hasInputBreakpoint="0" comment="" breakpointFlags="0" saveVersion="2">
				<OutputBreakpoints />
				<Behavior>
					<Sequence hasInputBreakpoint="0" comment="" breakpointFlags="0">
						<OutputBreakpoints />
						<TeleportAction hasInputBreakpoint="0" comment="" breakpointFlags="0">
							<OutputBreakpoints />
						</TeleportAction>
						<IfCondition hasInputBreakpoint="0" comment="" breakpointFlags="0">
							<OutputBreakpoints />
							<InstantSendMessageToNPC hasInputBreakpoint="0" comment="" breakpointFlags="0">
								<OutputBreakpoints />
							</InstantSendMessageToNPC>
						</IfCondition>
					</Sequence>
				</Behavior>
			</Root>
			<Forest />
			<Comments />
		</EditorData>
	</BehaviorTree>
</BehaviorTrees>